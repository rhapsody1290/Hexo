---
title: 4、Mysql面试题.

date: 2017-07-29 20:13:00

categories:
- 数据库

tags:
- 数据库

---

## 事务ACID属性

* 原子性（Atomicity）：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。
* 一致性（Consistent）：在事务开始和完成时，数据都必须保持一致状态（如转账钱不会少）。这意味着所有相关的数据规则都必须应用于事务的修改，以保持数据的完整性；事务结束时，所有的内部数据结构（如B树索引或双向链表）也都必须是正确的。
* 隔离性（Isolation）：并发事务之间互相影响的程度，适当的破坏一致性来提升性能与并行度。数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然。
* 持久性（Durable）：事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。

## 事务隔离等级

**并发时出现的问题及解决方案**

![](http://i.imgur.com/B36Axmn.png)

**事务隔离级别选择**

1、事务隔离级别越严格，并发副作用越小，对系统的性能影响越大，因为事务隔离实质上使事务在一定程度上”串行化”执行，与并发是矛盾的
2、不同的应用对读一致性和隔离程度是不同的，比如许多应用对”不可重复读”和”幻影读”并不敏感，可能更关注数据并发访问能力

## Mysql默认事务隔离等级

innoDB是MySQL默认的存储引擎，默认的隔离级别是RR，并且在RR的隔离级别下更进一步，**通过多版本并发控制（MVCC，Multiversion Concurrency Control ）解决不可重复读问题，加上间隙锁（也就是并发控制）解决幻读问题。**因此innoDB的RR隔离级别其实实现了串行化级别的效果，而且保留了比较好的并发性能。

## 如何实现事务隔离

1、读取数据前，加锁（悲观锁）
2、不加任何锁，在数据请求点生成一个快照，并用这个快照来提供一定级别的一致性读取（乐观锁）

## MVCC

MVCC是一种多版本并发控制机制

锁机制可以控制并发操作，但是其系统开销较大，而MVCC可以在大多数情况下代替行级锁，使用MVCC，能降低其系统开销

InnoDB 的 MVCC，是通过在每行记录后面保存两个隐藏的列来实现的，这两个列，**分别保存了这个行的创建时间，一个保存的是行的删除时间。**这里存储的并不是实际的时间值，而是系统版本号(可以理解为事务的ID)，没开始一个新的事务，系统版本号就会自动递增，事务开始时刻的系统版本号会作为事务的ID。

SELECT
1、InnoDB只会查找版本早于当前事务版本的数据行(也就是,行的系统版本号小于或等于事务的系统版本
2、行的删除版本要么未定义,要么大于当前事务版本号,这可以确保事务读取到的行，在事务开始之前未被删除. 

DELETE
InnoDB会为删除的每一行保存当前系统的版本号(事务的ID)作为删除标识. 

UPDATE
InnoDB执行UPDATE，实际上是**新插入了一行记录**，并保存其创建时间为当前事务的ID，**同时保存当前事务ID到要UPDATE的行的删除时间.**

详细：
http://blog.csdn.net/whoamiyang/article/details/51901888

## InnoDB和MyISAM区别

MySQL数据库分为Innodb和Myisam两类。两者最主要的区别是：**Innodb支持事务处理、外键和行级锁.而MyISAM不支持，所以如果CUD比较频繁或要求事务一致性的，使用Innodb比较好，反之使用Myisam比较好。**具体区别如下：

1、索引：MyISAM的索引和数据是分开的，并且索引是有压缩的，而Innodb是索引和数据放在一起，且没有使用压缩，因而Innodb比MyISAM体积更大。MyISAM每张表都包括三种文件：表定义文件（.frm）、数据文件（.myd)和索引文件（.myi)，而Innodb通常许多表保存在同一个文件中。此外，如果表数据非常大，通常也使用MyISAM。
2、InnoDB不支持FULLTEXT类型的索引。
3、对于AUTO_INCREMENT类型的字段，InnoDB中必须单独建索引，而在MyISAM中可以和其他字段一起建立联合索引。
4、没有where的SELECT COUNT(*)：MyISAM始终保留一张表的行数，因此这条语句几乎瞬间就可以执行完，而Innodb会一行行的累加。
5、锁：MyISAM表锁，Innodb行锁

## 索引

### 索引类型

1、普通索引

这是最基本的索引，它没有任何限制，比如上文中为title字段创建的索引就是一个普通索引，MyIASM中默认的BTREE类型的索引，也是我们大多数情况下用到的索引。

2、唯一索引

与普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值（注意和主键不同）。如果是组合索引，则列值的组合必须唯一，创建方法和普通索引类似。

3、全文索引（FULLTEXT）

MySQL从3.23.23版开始支持全文索引和全文检索，FULLTEXT索引仅可用于 MyISAM 表；他们可以从CHAR、VARCHAR或TEXT列中作为CREATE TABLE语句的一部分被创建，或是随后使用ALTER TABLE 或CREATE INDEX被添加。////对于较大的数据集，将你的资料输入一个没有FULLTEXT索引的表中，然后创建索引，其速度比把资料输入现有FULLTEXT索引的速度更为快。不过切记对于大容量的数据表，生成全文索引是一个非常消耗时间非常消耗硬盘空间的做法。

### 单列索引、多列索引

**单列索引**

考虑使用索引的主要有两种类型的列：在Where子句中出现的列，在join子句中出现的列

那么，我们是否可以简单地认为应该索引Where子句和join子句中出现的每一个列呢？差不多如此，但并不完全。我们还必须考虑到对列进行比较的操作符类型。MySQL只有对以下操作符才使用索引：<，<=，=，>，>=，BETWEEN，IN，以及某些时候的LIKE。

**多列索引**

**多个单列索引与单个多列索引的查询效果不同**，因为执行查询时，MySQL只能使用一个索引，会从多个索引中选择一个限制最为严格的索引。

	Select peopleid  
	FROM people   
	Where firstname='Mike'   
	      AND lastname='Sullivan' AND age=17;  

为了提高搜索效率，我们需要考虑运用多列索引。如果为firstname、lastname和age这三个列创建一个多列索引，MySQL只需一次检索就能够找出正确的结果

**多列索引中最左前缀（Leftmost Prefixing）**

现在我们有一个firstname、lastname、age列上的多列索引，我们称这个索引为fname_lname_age。当搜索条件是以下各种列的组合时，MySQL将使用fname_lname_age索引：
 
	firstname，lastname，age
	firstname，lastname
	firstname

**详细：**
http://greatwqs.iteye.com/blog/1897118

### 聚簇索引和非聚簇索引

**聚集索引**

1、表中行的物理存储顺序按照"索引键值顺序排列"，该索引称为"聚集索引"
2、每个表只能有一个聚集索引，因为数据只能按照一种方法进行排序。但该索引可以包含多个列（组合索引），就像电话簿按姓氏和名字进行组织一样
3、聚簇索引的叶节点就是数据节点

优点：
聚集索引对于那些经常要**搜索范围值**的列特别有效。使用聚集索引找到包含第一个值的行后，便可以确保包含后续索引值的行在物理相邻。

**非聚集索引**

1、索引中索引的**逻辑顺序**与磁盘上行的**物理存储**顺序不同（目录纯粹是目录，正文纯粹是正文的排序方式称为"非聚集索引"，查找记录时需要通过目录索引找到正文）
2、非聚簇索引的叶节点仍然是索引节点，只不过有一个指针指向对应的数据块

**总结**

1、**聚簇索引的叶节点就是数据节点。而非聚簇索引的叶节点仍然是索引节点，只不过有一个指针指向对应的数据块**

2、聚簇索引能提高多行检索的速度，而非聚簇索引对于单行的检索很快

详细：

http://www.cnblogs.com/aspnethot/articles/1504082.html

### 索引优化

1、何时使用聚集索引或非聚集索引？
2、索引不会包含有NULL值的列，使用默认值
3、使用短索引

## 什么情况下设置了索引但无法使用，索引无效

1) 以"%"开头的LIKE语句，模糊匹配：红色标识位置的百分号会导致相关列的索引无法使用
2) Or语句前后没有同时使用索引
3) 数据类型出现隐式转化（如varchar不加单引号的话可能会自动转换为int型，会使索引无效，产生全表扫描。）
4) 在索引列上使用IS NULL 或IS NOT NULL操作。索引是不索引空值的，所以这样的操作不能使用索引，可以用其他的办法处理，例如：数字类型，判断大于0，字符串类型设置一个默认值，判断是否等于默认值即可
5) 在索引字段上使用not，<>，!=，eg<> 操作符（不等于）：不等于操作符是永远不会用到索引的，因此对它的处理只会产生全表扫描。 用其它相同功能的操作运算代替，如 a<>0 改为 a>0 or a<0
6) 对索引字段进行计算操作
7) 在索引字段上使用函数

## 分页查询

![](http://i.imgur.com/iUxof3t.png)

## 参考

从特性说起，漫谈MySQL中的事务及其实现
http://dbaplus.cn/news-11-515-1.html?hmsr=toutiao.io&utm_medium=toutiao.io&utm_source=toutiao.io

