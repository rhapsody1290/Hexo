---
title: 4、Mysql面试题.

date: 2017-07-29 20:13:00

categories:
- 数据库

tags:
- 数据库

---

## 事务ACID属性

* 原子性（Atomicity）：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。
* 一致性（Consistent）：在事务开始和完成时，数据都必须保持一致状态（如转账钱不会少）。这意味着所有相关的数据规则都必须应用于事务的修改，以保持数据的完整性；事务结束时，所有的内部数据结构（如B树索引或双向链表）也都必须是正确的。
* 隔离性（Isolation）：并发事务之间互相影响的程度，适当的破坏一致性来提升性能与并行度。数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然。
* 持久性（Durable）：事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。

一致性理解：

数据操作后前后一致，A账户增加100，B账户就减少100，总数没少，一致的
专业术语是：状态A，经过事务的操作B，转移到状态C，B的操作完全应用在A上，产生的结果B是准确得
准确是指什么准确
不是有可能操作B中断，这些异常，可能B的操作是加10，但是分为10个+1的中间操作，但是操作B中断了
可能 A 经过操作B 得到结果C 是 +1，而不是+10

**一致性要求保证操作B的中间结果对外是不可见的**
要不就是全部执行，要不就不执行
就回到刚才那里例子，银行转账
这不还是原子性么……
原子性是一致性的保障哈
原子性、一致性和持久性是通过redo 和 undo 日志文件实现的
所以你看他们的实现都在一起

## 事务隔离等级

**并发时出现的问题及解决方案**

![](http://i.imgur.com/B36Axmn.png)

**事务隔离级别选择**

1、事务隔离级别越严格，并发副作用越小，对系统的性能影响越大，因为事务隔离实质上使事务在一定程度上”串行化”执行，与并发是矛盾的
2、不同的应用对读一致性和隔离程度是不同的，比如许多应用对”不可重复读”和”幻影读”并不敏感，可能更关注数据并发访问能力

## Mysql默认事务隔离等级

innoDB是MySQL默认的存储引擎，默认的隔离级别是RR，并且在RR的隔离级别下更进一步，**通过多版本并发控制（MVCC，Multiversion Concurrency Control ）解决不可重复读问题，加上间隙锁（也就是并发控制）解决幻读问题。**因此innoDB的RR隔离级别其实实现了串行化级别的效果，而且保留了比较好的并发性能。

## 如何实现事务隔离

1、读取数据前，加锁（悲观锁）
2、不加任何锁，在数据请求点生成一个快照，并用这个快照来提供一定级别的一致性读取（乐观锁）

## MVCC

MVCC是一种多版本并发控制机制

锁机制可以控制并发操作，但是其系统开销较大，而MVCC可以在大多数情况下代替行级锁，使用MVCC，能降低其系统开销

InnoDB 的 MVCC，是通过在每行记录后面保存两个隐藏的列来实现的，这两个列，**分别保存了这个行的创建时间，一个保存的是行的删除时间。**这里存储的并不是实际的时间值，而是系统版本号(可以理解为事务的ID)，没开始一个新的事务，系统版本号就会自动递增，事务开始时刻的系统版本号会作为事务的ID。

SELECT
1、InnoDB只会查找版本早于当前事务版本的数据行(也就是,行的系统版本号小于或等于事务的系统版本
2、行的删除版本要么未定义,要么大于当前事务版本号,这可以确保事务读取到的行，在事务开始之前未被删除. 

DELETE
InnoDB会为删除的每一行保存当前系统的版本号(事务的ID)作为删除标识. 

UPDATE
InnoDB执行UPDATE，实际上是**新插入了一行记录**，并保存其创建时间为当前事务的ID，**同时保存当前事务ID到要UPDATE的行的删除时间.**

详细：
http://blog.csdn.net/whoamiyang/article/details/51901888

## InnoDB和MyISAM区别

MySQL数据库分为Innodb和Myisam两类。两者最主要的区别是：**Innodb支持事务处理、外键和行级锁.而MyISAM不支持，所以如果CUD比较频繁或要求事务一致性的，使用Innodb比较好，反之使用Myisam比较好。**具体区别如下：

1、索引：MyISAM的索引和数据是分开的，并且索引是有压缩的，而Innodb是索引和数据放在一起，且没有使用压缩，因而Innodb比MyISAM体积更大。MyISAM每张表都包括三种文件：表定义文件（.frm）、数据文件（.myd)和索引文件（.myi)，而Innodb通常许多表保存在同一个文件中。此外，如果表数据非常大，通常也使用MyISAM。
2、InnoDB不支持FULLTEXT类型的索引。
3、对于AUTO_INCREMENT类型的字段，InnoDB中必须单独建索引，而在MyISAM中可以和其他字段一起建立联合索引。
4、没有where的SELECT COUNT(*)：MyISAM始终保留一张表的行数，因此这条语句几乎瞬间就可以执行完，而Innodb会一行行的累加。
5、锁：MyISAM表锁，Innodb行锁

## 索引

### 索引类型

1、普通索引

这是最基本的索引，它没有任何限制，比如上文中为title字段创建的索引就是一个普通索引，MyIASM中默认的BTREE类型的索引，也是我们大多数情况下用到的索引。

2、唯一索引

与普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值（注意和主键不同）。如果是组合索引，则列值的组合必须唯一，创建方法和普通索引类似。

3、全文索引（FULLTEXT）

MySQL从3.23.23版开始支持全文索引和全文检索，FULLTEXT索引仅可用于 MyISAM 表；他们可以从CHAR、VARCHAR或TEXT列中作为CREATE TABLE语句的一部分被创建，或是随后使用ALTER TABLE 或CREATE INDEX被添加。////对于较大的数据集，将你的资料输入一个没有FULLTEXT索引的表中，然后创建索引，其速度比把资料输入现有FULLTEXT索引的速度更为快。不过切记对于大容量的数据表，生成全文索引是一个非常消耗时间非常消耗硬盘空间的做法。

### 单列索引、多列索引

**单列索引**

考虑使用索引的主要有两种类型的列：在Where子句中出现的列，在join子句中出现的列

那么，我们是否可以简单地认为应该索引Where子句和join子句中出现的每一个列呢？差不多如此，但并不完全。我们还必须考虑到对列进行比较的操作符类型。MySQL只有对以下操作符才使用索引：<，<=，=，>，>=，BETWEEN，IN，以及某些时候的LIKE。

**多列索引**

**多个单列索引与单个多列索引的查询效果不同**，因为执行查询时，MySQL只能使用一个索引，会从多个索引中选择一个限制最为严格的索引。

	Select peopleid  
	FROM people   
	Where firstname='Mike'   
	      AND lastname='Sullivan' AND age=17;  

为了提高搜索效率，我们需要考虑运用多列索引。如果为firstname、lastname和age这三个列创建一个多列索引，MySQL只需一次检索就能够找出正确的结果

**多列索引中最左前缀（Leftmost Prefixing）**

现在我们有一个firstname、lastname、age列上的多列索引，我们称这个索引为fname_lname_age。当搜索条件是以下各种列的组合时，MySQL将使用fname_lname_age索引：
 
	firstname，lastname，age
	firstname，lastname
	firstname

**详细：**
http://greatwqs.iteye.com/blog/1897118

### 聚簇索引和非聚簇索引

**聚集索引**

1、表中行的物理存储顺序按照"索引键值顺序排列"，该索引称为"聚集索引"
2、每个表只能有一个聚集索引，因为数据只能按照一种方法进行排序。但该索引可以包含多个列（组合索引），就像电话簿按姓氏和名字进行组织一样
3、聚簇索引的叶节点就是数据节点

优点：
聚集索引对于那些经常要**搜索范围值**的列特别有效。使用聚集索引找到包含第一个值的行后，便可以确保包含后续索引值的行在物理相邻。

**非聚集索引**

1、索引中索引的**逻辑顺序**与磁盘上行的**物理存储**顺序不同（目录纯粹是目录，正文纯粹是正文的排序方式称为"非聚集索引"，查找记录时需要通过目录索引找到正文）
2、非聚簇索引的叶节点仍然是索引节点，只不过有一个指针指向对应的数据块

**总结**

1、**聚簇索引的叶节点就是数据节点。而非聚簇索引的叶节点仍然是索引节点，只不过有一个指针指向对应的数据块**

2、聚簇索引能提高多行检索的速度，而非聚簇索引对于单行的检索很快

详细：

http://www.cnblogs.com/aspnethot/articles/1504082.html

## Mysql 日志

事务的隔离用是通过锁机制实现的，原子性、一致性和持久性是通过redo 和 undo 日志文件实现的

**概述**

1、当开始一个事务时候，会纪录该事务的一个日志序列号
2、当事务执行时候，在写数据之前，需要先写日志，这种方式称为预写日志方式WAL（Write-Ahead Logging）。
3、undo记录了数据在事务开始之前的值，当事务执行失败或者ROLLBACK时可以通过undo记录的值来恢复数据 => 缺点：单纯使用undo保证原子性和持久性需要在事务提交之前将数据写到磁盘，浪费大量I/O。
4、引入redo日志记录数据修改后的值，可以避免数据在事务提交之前必须写入到磁盘的需求，减少I/O。

**undo**

undo记录了数据在事务开始之前的值，当事务执行失败或者ROLLBACK时可以通过undo记录的值来恢复数据。例如 AA和BB的初始值分别为3，5。

	A 事务开始
	B 记录AA=3到undo_buf
	C 修改AA=1
	D 记录BB=5到undo_buf
	E 修改BB=7
	F 将undo_buf写到undo(磁盘)
	G 将data_buf写到datafile(磁盘)
	H 事务提交

如果事务在F之前崩溃由于数据还没写入磁盘，所以数据不会被破坏。 
如果事务在G之前崩溃或者回滚则可以根据undo恢复到初始状态。 
数据在任务提交之前写到磁盘保证了持久性。 
但是单纯使用undo保证原子性和持久性需要在事务提交之前将数据写到磁盘，浪费大量I/O。

**思考题：为什么要将undo_buf写到磁盘，而不是直接执行G**

如果G崩溃如果不将undo写入磁盘就没法回滚，所以需要进行undo的持续化，所以使用undo来保证原子性和持久性会大量浪费IO，主要体现在多谢了undo的操作

**redo：**

引入redo日志记录数据修改后的值，可以避免数据在事务提交之前必须写入到磁盘的需求，减少I/O。
通过undo保证事务的原子性，redo保证持久性。 

	A 事务开始
	B 记录AA=3到undo_buf
	C 修改AA=1 记录redo_buf
	D 记录BB=5到undo_buf
	E 修改BB=7 记录redo_buf
	F 将redo_buf写到redo（磁盘）
	G 事务提交

F之前崩溃由于所有数据都在内存，恢复后重新冲磁盘载入之前的数据，数据没有被破坏。 
FG之间的崩溃可以使用redo来恢复。 
G之前的回滚都可以使用undo来完成。

**两个概念**

1、崩溃：操作失败，开机后需要继续执行 
2、回滚：取消之前的执行结果
然后用redo可以解决崩溃问题
用undo可以回滚

qm总结：
1、undo：宕机恢复时，如果undo日志没有commit，则进行回滚
操作步骤：持久化undo日志，数据库持久化，commit
缺点：commit前完成数据持久化，同步IO

2、redo：宕机恢复时，如果redo日志已经commit，将数据库数据持久化到磁盘
操作步骤：持久化redo日志，commit之后在适当时间进行数据库持久化
优点：解决同步IO

3、undo/redo：事务执行时持久化undo/redo日志，宕机恢复时，如果没有commit，则利用undo回滚；如果已经commit，则恢复执行redo操作，持久化到磁盘

详细：
http://blog.csdn.net/sk199048/article/details/50596092
http://blog.csdn.net/mchdba/article/details/12242685
http://blog.chinaunix.net/uid-20196318-id-3812190.html

## 分页查询

![](http://i.imgur.com/iUxof3t.png)

## 参考

从特性说起，漫谈MySQL中的事务及其实现
http://dbaplus.cn/news-11-515-1.html?hmsr=toutiao.io&utm_medium=toutiao.io&utm_source=toutiao.io

