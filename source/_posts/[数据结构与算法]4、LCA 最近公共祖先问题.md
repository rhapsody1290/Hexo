---
title: 4、LCA 最近公共祖先问题

date: 2017-05-26 10:03:00

categories:
- 数据结构与算法

tags:
- LCA

---

## 问题描述

最近公共祖先问题可以将树从下往上看，两个目标节点到树的根节点组成的两条链表，求两条链表第一次相遇的地方

如下图所示，求3，4的公共祖先，则目标节点到根的链表分别是：3——>1、4——>2——>1，两条链表第一次相遇的地方是1，那么最近公共祖先就是1

![](http://i.imgur.com/KLZozPV.png)

另外，4 和 5 的最近公共祖先是2，5和3的最近公共祖先是1，2和1的最近公共祖先是1

## Tarjan(离线)算法

### 原理（最浅显易懂的描述）

![](http://i.imgur.com/BXMZV63.png)

用集合的角度去思考 LCA 问题：

10 与 1，2，5，6 的 LCA 都为 1
10 与 3，7 的 LCA 都为 3
10 与 8，9，11 的 LCA 都为 8
10 与 10，12 的 LCA 都为 12

Tarjan 算法可以批量查询，假设有求5，10的 LCA，3、10的LCA，9、10的LCA

当 DFS 遍历到节点 10 时，查看查询语句中是否有与10相关的：
如果求 5、10 的 LCA，只要求当前5所在的集合的祖先就行了，结果就是8
如果求 3、10 的 LCA，只要求3所在集合的祖先就行了，结果是3
如果求 9、10 的 LCA，只要求9所在结合的祖先就行了，结果是8

那么问题的关键就是 <font color='red'>**集合怎么表示，集合如何构建？**</font>

### 并查集

可以发现，当 **一个数A** 与 **集合中的元素B** 求 LCA 时，<font color='red'>结果都是指向同一个祖先</font>，我们将设置一个数据结构将各个节点**组成集合**，并且能够根据集合中的点**访问到祖先**，可以使用 **并查集** 满足上述要求 。并查集维护了**当前节点与父节点之间的关系，最终可以获得祖先节点**

**并查集是当前节点与father节点的映射关系**，是一个Key-Value的结构，可以用数组的下标和数组的值作为存储结构，按照上图左子树举个例子：

![](http://i.imgur.com/uP9FUsk.png)

初始化的时候每个节点的父节点都是自己，如果**当前节点的father就是自己本身**，那么他就是集合的根节点

并查集查集合根节点：

    public int find(int x) {
        int r = x;
        while(father[r] != r){
            r = father[r];
        }
        return r;
    }

并查集基本介绍完毕，现在可以用并查集来表示集合了，并且找到集合的根节点，接下来的问题，**哪些节点可以归为同一个集合？**

### 算法描述（思路）

![](http://i.imgur.com/BXMZV63.png)

还是之前那张图，对于新搜索到的一个结点u，先创建由u构成的集合，再对u的每颗子树进行搜索，每搜索完一棵子树，将子节点归到集合u中

1.任选一个点为根节点，从根节点开始。
2.遍历该点u所有子节点v，并标记这些子节点v已被访问过。
3.若是v还有子节点，返回2，否则下一步。
4.合并v到u上。
5.寻找与当前点u有询问关系的点v。
6.若是v已经被访问过了，则可以确认u和v的最近公共祖先为v被合并到的父亲节点a。

伪代码

	Tarjan(u)//marge和find为并查集合并函数和查找函数
	{
	    for each(u,v)    //访问所有u子节点v
	    {
	        Tarjan(v);        //继续往下遍历
	        marge(u,v);    //合并v到u上
	        标记v被访问过;
	    }
	    for each(u,e)    //访问所有和u有询问关系的e
	    {
	        如果e被访问过;
	        u,e的最近公共祖先为find(e);
	    }
	}

### 算法模拟

http://www.cnblogs.com/JVxie/p/4854719.html

### 代码实现

## OJ

http://www.cnblogs.com/JVxie/p/4854719.html




