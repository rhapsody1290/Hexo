---
title: 运输层

date: 2016-10-11 00:00:00

categories:
- 网络安全

tags:
- 网络安全

---

## 概述

### 运输层服务

    计算机网络最基本的问题:
    ● 两个实体怎样才能在一种会丢失或损坏数据的介质上可靠得通信
    ● 控制运输层实体的传输速率以避免网络中的拥塞，或从拥塞中恢复出来
    
    运输层协议为运行在不同主机上的应用进程之间提供了逻辑通信（Logic Communication）。通过逻辑，运行不同进程的主机好像直接相连一样，实际上这些主机也许位于地球的两侧，通过很多路由器及都中不同类型的链路相连
    
    运输层协议实在端系统中而不是在网络路由器中实现的。
        1、在发送方，运输层将接收到的来自发送应用程序的报文分成较小的块，并为每块加上一个运输层首部。在发送方端系统中，运输层将这些报文段传递给网络层，网络层再将其分装成网络层分组，并向目的地发送。
        2、在接收方，网络层从数据报中提取出运输层报文段，并将该报文段向上交给运输层。运输层则处理接受到的报文段，使得接受方应用程序可应用该报文段中的数据
    
    运输层TCP和UDP的分组称为报文段，网络层分组称为数据报
    
    网络层协议叫ip，全程是网际协议，IP为主机之间提供了逻辑通信，IP的服务模型是尽力而为交付服务。他不确保报文段的交付，不保证报文段的按序交付，更不保证报文段中的数据完整性。所以IP成为不可靠服务。
    
    ★★★
    UDP提供的服务：进程间数据交付、差错检测（运输层最低限度的两个服务，也是UDP仅有的两个服务）
    TCP提供附加服务：提供可靠数据传输（流量控制，序号，确认，定时器等技术）、拥塞控制

### 多路复用与多路分解

    接收主机中的运输层并没有直接将数据交付给进程，而是通过一个中间的套接字来传递。接收主机上可能有多个套接字，每个套接字都有唯一的标识符。在运输层报文段设置几个字段，接收端检查这些字段并标识出接收套接字。
    
    1、从源主机发送报文段
        ● 将运输层报文段中的数据交付到正确的套接字的工作称为多路分解
        ● 从源主机的不同套接字中收集数据块，并为每个数据块分装上首部信息从而生成报文段，然后将报文段传递到网络的工作称为多路复用
        
    2、目的主机接受报文段
        ● 报文段达到目的主机，根据报文段上的端口号定位到相应进程的套接字（多路分解）
        ● 运输层收集套接字输出的数据形成运输层报文段（多路复用）
    
    运输层多路复用的要求：
        ❶ 套接字有唯一标识符
        ❷ 每个报文段有特殊字段（源端口、目的端口）来指示该报文段要交付的套接字
        
    ● UDP套接字由一个包含目的IP地址和目的端口号的二元组来标识，如果两个UDP报文段有不同的源IP地址或源端口号，但具有相同的目的IP地址和目的端口号，那么这两个报文段将通过相同的目的套接字定向到相同的目的进程
    
    ● TCP套接字由一个四元组（源IP地址、源端口号、目的IP地址、目的端口号）来标识，两个不同源IP地址或或源端口号的TCP报文会被定向到两个不同的套接字

## UDP

    UDP只是做了运输协议能够做的最少工作，除了多路复用/多路分解功能及一些轻型差错检测，它几乎没有对IP增加别的东西
    
    问题：有些应用程序更适合用UDP，而不是提供可靠数据传输服务的TCP？
    答：
        ● 应用层能更好地控制要发送的数据和发送时间。应用层将数据交给UDP，UDP就会在数据上附上多路复用/多路分解所需的源端口号和目的端口号，及两个其他字段，并立即将其传递给网络层。而TCP有一个拥塞控制机制，当链路非常拥塞时，遏制运输层TCP发送方，同时TCP会重新发送报文段知道目的主机收到此报文并加以确认，而不管可靠交付时间需要多长。实时应用通常要求最快的发送速率，能容忍一些数据丢失
        ● 无需连接确立。TCP在数据传输之前需要经过三次握手，UDP却不需要任何准备即可进行数据传输
        ● 无连接状态。TCP需要在端系统中维护连接状态，连接状态包括接受和发送缓存、拥塞控制参数、序号与确认好的参数。UDP不维护连接状态
        ● 分组首部开销小。每个TCP报文段都有20字节的首部开销，而UDP仅有8个字节的开销
        
    ★★★
    UDP应用可以实现可靠数据传输，通过在应用程序自身中建立可靠性机制（例如增加确认和重传机制来实现）。这会增加开发人员的工作，但应用程序可以进行可靠通信，而无需受制于TCP拥塞控制机制引起的传输速率约束。

### UDP报文结构
![UDP报文结构](http://img.blog.csdn.net/20160406154258808)
    
    UDP首部只有四个字段，每个字段由两个字节组成[源端口号、目的端口号、长度、校验和]，共8个字节，应用层数据占用UDP报文段的数据字段。
        ● 源端口和目的端口是执行多路复用/多路分解的必备条件
        ● 接受主机使用校验和来检查报文段是否存在差错
        ● 长度字段包括首部在内的UDP报文长度，字节为单位
        
## 可靠数据传输的原理
### 构建可靠数据传输协议

![这里写图片描述](http://img.blog.csdn.net/20160406161249976)

    1、完全可靠信道上的可靠数据传输：rdt1.0
        最简单的情况，底层信道是完全可靠的。
        图3.9显示了rdt1.0发送方和接收方的有限状态机。初始状态用虚线表示。
        ● rdt的发送方通过rdt_send(data)从高层接收数据，产生一个包含该数据的分组（make_pkt(data)）,并且将数据发送到信道中。状态回到等待状态。
        ● 接收方，rdt通过rdt_rcv(packet)事件从底层信道接收一个分组，从分组中取出数据(经extract(packet,data)动作)，并将数据上传给高层（通过deliver_data(data)动作）

![这里写图片描述](http://img.blog.csdn.net/20160407072723981)

    2、具有比特差错信道上的可靠数据传输：rdt2.0
        考虑你自己是怎样通过电话口述一条长消息：报文接受者听到、明白每句话都会说OK；如果听到依据含糊不清的话，他可能要求你重复那句话。这种口述消息协议使用了肯定确认（OK），否定确认（请重复一遍）。这些控制报文使得接收方可以让发送方知道哪些内容被正确接受，哪些内容有误需要重传。计算机网络中，基于这种重传机制的可靠数据传输协议称为自动重传请求（ARQ）协议。
        ARQ协议处理比特差错：
            ● 差错检测
            ● 接收方反馈：肯定确认（ACK），否定确认（NAK）
            ● 重传
        当rdt_send(data)事件发生时，发送方将产生一个包含待发送数据的分组(sndpkt)，然后经由udp_send(pkt)发送该分组，状态跳转到等待接收方的ACK或NAK分组。如果收到数据包且收到一个ACK，则发送方知道最近传输的分组已被正确接收，状态跳转到等待上层数据状态。如果收到一个NAK分组，该协议重传最后一个分组并等待接收方的响应。
        如果发送一个数据包出现差错，则发送方将会一直重传该数据包，直到接收到ACK。这种行为也成为停等协议
        接收方当分组到达时，接收方根据分组是否受损回答ACK或NAK
        
        缺陷：如果ACK或NAK分组受损，发送方无法知道是否正确接收了上一块发送的数据（如果发送数据包后没收到ACK或NAK，则状态一直停留在等待ACK或NAK中）
        解决方法：当发送方收到含糊不清的ACK或NAK分组时，只需重新发送当前数据分组即可。但这会引入冗余分组，会造成接收方无法判断接收到的分组是新的还是一次重传。

![这里写图片描述](http://img.blog.csdn.net/20160407105631251)   ![这里写图片描述](http://img.blog.csdn.net/20160407105648095) 

        rdt2.1解决了这个问题，在数据分组中添加一个序号字段，对于停等协议，1比特序号就足够了，前后接受的序号相同则代表是重传分组。
        发送方初始状态处于等待来自上层的调用0状态。当事件rdt_send(data)发生时，生成一个序号为0的数据包，向信道发送数据，状态跳转到等待序号为0的数据的ACK或NAK。如果正确接收到一个数据包，但数据包受损或是NAK，则继续等待，直到接收到的数据包没有损坏而且是ACK，说明0号数据包已经被正常接收，状态跳转到等待发送数据包1的状态。之后同理。
        在接收方，初始状态为等待数据包0的状态。如果收到的数据包破损，则向发送方发送一个NAK。或者你现在想收到序号为0的数据包，但发送过来一个序号为1的数据包，说明发送方重发了数据包1，则发送一个ACK。因为是重发，所以不需要提取数据包中的数据。如果正确接收到序号为0的分组，则提取出数据，传送给上层，并想发送方发送一个ACK，告知已经成功接收数据包0，状态跳转到等待接收序号为1的数据包。之后同理。
![这里写图片描述](http://img.blog.csdn.net/20160407110607754)
![这里写图片描述](http://img.blog.csdn.net/20160407110946553)   
        
        rdt2.2接收到受损的分组，发送一个对上次正确接受的分组的ACK。发送方接收到对同一个分组的两个ACK（冗余ACK），就知道接收方没有正确接收到跟在被确人两次的分组后面的分组。
        当发送方处于等待来自上层的调用0的状态时，rdt_send(data)事件发生，生成一个序号为0的数据包，通过udt_send(sndpkt)将数据发送到信道。状态跳转到等待序号为0的数据包的ACK。如果接收到为受损的ACK数据包，状态跳转到等待发送序号为1的数据包的状态。如果收到受损的数据包，或数据包的序号不为0（确认的是之前的序号，则当前发送的数据包接收方没有正确被接收），则继续处于等待序号为0的数据包的ACK。之后同理。
        在接收方，注意到初始化时oncethru = 0，如果发送方第一个数据包出现错误，则接收方一直将处于等待来自下层的0这个状态，不用发累计确认ACK。当接收到的数据包没有受损，而且刚好是等待的序号为0的分组，接收方提取出分组的数据，传递给上层，然后向发送方发送序号为0的ACK，通知发送方已经成功接受序号为0的分组，状态跳转到等待序号为1的数据包这个状态。如果之前的情况，向发送方发送序号为0的ACK出现损坏，则发送方会再次发送一个序号为0的数据包。这种情况下接收方会重新发送之前的确认包，告知发送方数据包已经接受，防止重复接受，接收方也就不需要提取数据包的消息。除了重发的情况，如果接受到破损数据，也将重新发送之前的确认包，接收方就知道确认包之后的数据没有被正确接受。之后又同理。
        
 ![这里写图片描述](http://img.blog.csdn.net/20160407224831968) 
 
    3.具有比特差错的丢包信道上的可靠数据传输：rdt 3.0 
        rdt2.2已经解决了发生丢包后该做些什么，通过检验和、序号、ACK分组和重传等方式。现在需要解决的问题是怎样检测丢包。
        我们让发送方负责检测和恢复丢包。假定发送方传输一个数据分组，该分组丢失或该分组的ACK丢失，这样发送方收不到来自接收方的响应。如果发送方愿意等待足够长的时间以便确认分组已丢失，则只需重传该数据分组即可。
        从发送方的观点来看，重传是一种万能灵药。发送方不知道是一个数据分组丢失、一个ACK丢失，还是该分组或ACK只是过度时延，所有的情况采取的动作都是同样的：重传。为了实现基于时间的重传机制，需要一个倒计数定时器，在一个给定的时间过期后，可中断发送方。
        状态图：初始状态为等待来自上层的调用0状态，当事件rdt_send(data)发生时，生成一个序号为0的数据包，发送到信道，同时启动定时器，状态跳转到等待数据包0的ACK。如果正确无差错的ACK，则数据包0成功被接收，停止计时器，状态跳转到等待上次调用发送序号为1的数据包。若在等待ACK 0的时候，收到受损数据包，或者收到序列为1的ACK（说明当前发送的数据包没有成功接收），需要重传数据包，但先不发送，等到计数器超时后再发送（因为是基于定时器的重发机制），并且重新开启定时器，状态仍为等待ACK 0.在等待来自上层的调用1的时候，此时已经完成数据的接收，但为什么会收到回复？因为如果超时时间过短，会出现过早超时的情形，发送方间隔发送两个相同的数据包，同时连个数据包都得到了回应ACK，会选择接收第一个ACK，第二个则忽略。

![这里写图片描述](http://img.blog.csdn.net/20160407231948479)
    
### 流水线可靠数据传输        

    允许发送方发送多个分组而无需等待确认，这种技术称为流水线。
    ● 必须增加序号范围，每个传输的分组必须有一个唯一的序号
    ● 协议的发送方和接收方必须缓存多个分组
    ● 所需序号范围和对缓冲的要求取决于数据传输协议处理丢失、损坏及过度延时分组的方式，解决流水线的差错恢复有两种基本的方法：回退N步和选择重传
    
### 回退N步（GBN）

![这里写图片描述](http://img.blog.csdn.net/20160408103441813)
    
    [0，base-1]内的序号对应于已经发送并确认过的分组，[base，nextseqnum-1]内的序号对应于已经发送，但未被确认的分组。[nextseqnum，base+N-1]内的序号可用于那些要被立即发送的分组，其数据来自上层。
    那些已经被发送但还未被确认的分组的序号范围可以看成是一个在序号范围内长度为N的窗口，并且随着协议的运行，该窗口在序好空间向前滑动，因此N常被称为窗口长度，GBN协议被称为滑动窗口协议

![这里写图片描述](http://img.blog.csdn.net/20160408110239599)
![这里写图片描述](http://img.blog.csdn.net/20160408110310178)

    GBN发送方必须响应以下三种类型的事件：
    ● 上层的调用。当上层调用rdt_send()，发送方首先检查发送窗口是否已满。如果未满则创建一个分组将其发送，变量也响应的更新。如果窗口已满，发送方将数据返回给上层，通知上次该窗口已满，然后上层可能会过一会再试 
    ●
    ●