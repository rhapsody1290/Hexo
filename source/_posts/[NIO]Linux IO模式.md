---
title: Linux IO模式

date: 2017-08-20 23:08:00

categories:
- NIO

tags:
- NIO

---

## 用户空间和内核空间

操作系统的核心是内核，独立于普通的应用程序，**可以访问受保护的内存空间，也有访问底层硬件设备的所有权限**。<font color='red'>**为了保证用户进程不能直接操作内核（kernel），保证内核的安全**</font>，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间

针对linux操作系统而言，**将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间**，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。

## 进程切换过程

1. 保存处理机上下文，包括**程序计数器和其他寄存器。**
2. 更新**PCB信息**。
3. 把进程的**PCB移入相应的队列**，如就绪、在某事件阻塞等队列。
4. 选择另一个进程执行，并更新其PCB。
5. 更新内存管理的数据结构。
6. 恢复处理机上下文。

## 阻塞与非阻塞

* 阻塞是如果数据没有准备好，进程必须等待，也不能处理其他任务
* 非阻塞是如果没数据准备，立刻返回一个error，不需要等待，所以一般需要多次轮训来判断数据是否准备好

## select

当用户进程调用了select，那么整个进程会被block，而同时，**kernel会"监视"所有select负责的socket**，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。



所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。）

用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。
我:
可以发现non-blocking IO和asynchronous IO的区别还是很明显的。在non-blocking IO中，虽然进程大部分时间都不会被block，但是它仍然要求进程去主动的check，并且当数据准备完成以后，也需要进程主动的再次调用recvfrom来将数据拷贝到用户内存。而asynchronous IO则完全不同。它就像是用户进程将整个IO操作交给了他人（kernel）完成，然后他人做完后发信号通知。在此期间，用户进程不需要去检查IO操作的状态，也不需要主动的去拷贝数据。
我:
select/poll返回后需要自己遍历文件，epoll直接在完成后调用回调函数
我:
如果空闲文件特别多，使用epoll会更高校

## 参考

Linux IO模式及 select、poll、epoll详解
https://segmentfault.com/a/1190000003063859
