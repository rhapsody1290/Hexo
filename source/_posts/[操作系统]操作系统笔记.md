---
title: 操作系统笔记

date: 2017-05-22 19:22:00

categories:
- 操作系统

tags:
- 操作系统

---


## 进程管理

![这里写图片描述](http://img.blog.csdn.net/20170331235858705?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXEzNjkyMDExOTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

### 进程与线程

**1、进程概念**

进程几部分组成：

* 进程控制块（PCB）：标识进程的存在，描述进程的执行状态
* 程序段：能够被进程调度程序调度到CPU上执行的程序代码段
* 数据段：进程中处理的原始数据或者计算的中间结果、结果数据

进程控制块组成：

* 进程标识符（PID）
* 进程当前状态：就绪/执行/阻塞
* 进程队列指针：记录PCB队列中下一个PCB的地址。系统中可能会组织多个PCB队列，如就绪队列、阻塞队列
* 程序和数据地址
* 进程优先级
* **CPU现场保护**
* 通信信息：记录进程执行过程中与别的进程发生的信息交换情况
* 家族联系：进程创建子进程，形成进程家族树。PCB中指明了子进程和父进程的标识
* 占有资源清单

为什么PCB是进程存在的标志？
系统通过PCB对进程进行控制：1、当系统调度到某进程后，根据其PCB中保存的处理机状态信息，恢复运行的现场，并根据PCB中的程序和数据的内存地址，找到其程序和数据 2、 当进程暂停执行时，将处理机环境保存在PCB中 3、进程间同步、通信时都要访问PCB

**2、进程状态与转换：**

1、三种状态

* 就绪：**获得除处理器之外的所有资源**，一旦获得处理器就立刻可以执行
* 执行：进程在CPU上执行
* 阻塞：由于发生某事件（例如IO等待）而无法执行下去

就绪和阻塞的区别：
处于就绪状态，当分配处理器时，进程能够立刻执行；阻塞状态时，即使把处理器分配给该进程，它也无法进行

2、进程状态的相互转换

![](http://i.imgur.com/M8giTeg.jpg)

注意：线程进行阻塞状态后，若等到期望的事件发生，先进入就绪状态，等调度程序选中该进程时，进程才能执行

**3、进程控制**

进程的控制包括进程的**创建、撤销、阻塞和唤醒**，这些功能一般由**操作系统的内核**来实现

操作系统内核：把一些与硬件紧密联系的模块，或运行频率较高的模块，以及许多公用的模块安排在靠近硬件的软件层次中，并使他们常驻内存，提高操作系统的效率



**4、进程组织**

**5、进程通信：共享存储系统、消息传递系统、管道通信**

**6、进程概念与多线程模型**

### 处理器调度

**1、调度的基本概念**

**2、调度时机、切换与过程**

**3、调度的基本原则**

**4、调度方式**

**5、典型调度算法**

### 同步与互斥

**1、进程同步的基本概念**

**2、实现临界区互斥的基本方法**

**3、信号量**

**4、管程**

**5、经典同步问题**

### 死锁

**1、死锁概念**

**2、死锁处理策略**

**3、死锁预防**

**4、死锁避免**

### 死锁检测和解除

## 中央处理器

CPU由运算器、控制器、寄存器及高速缓存组成

CPU状态：
1、内核态：运行操作系统程序
2、用户态：运行用户程序

CPU状态转换：
1、用户态——>内核态：唯一途径是中断、异常、陷入机制
2、内核态——>用户态：设置程序状态字PSW

## 中断

**涉及到的对象：CPU、CPU正在处理的程序、事件、事件处理程序**

定义：中断是CPU对某个事件的反应。CPU暂停正在执行的程序，保留现场自动转去执行事件的处理程序，完成后返回断点继续执行被打断的程序

作用：

1、支持CPU和设备之间的并行操作。当CPU启动设备进行输入输出后，设备可以独立工作，CPU转去处理其他事情。当设备完成输出/输出后，通过向CPU发中断报告此次输出/输出结果，让CPU决定如何处理以后的事情
2、CPU执行指令时异常的引入。如果执行指令时出现算术溢出，除零等异常，硬件改变CPU的执行流程，转到相应的错误处理程序或异常处理程序

理解：

1、小明在看书，这时候电话来了，小明把书签放在书上，然后去接电话，回来后继续从刚才那个地方开始看，这个是中断的概念
2、小明在看书，这时候有点口渴了，小明将书签放在书上，然后去喝口水，回来继续看书。口渴了相当于异常出现，去喝水相当于是异常处理程序

事件：

![](http://i.imgur.com/D0psc3v.png)

中断处理流程：

CPU取出一条执行，并执行，如果检测到中断，获得中断码（处理器状态），并通过查中断向量表找到中断处理程序

![](http://i.imgur.com/VkjTF7C.png)

中断向量表

中断向量表是中断码（处理器状态）与中断处理程序的映射。执行过程中按照中断号的不同，通过中断向量表执行不同的中断处理程序

![](http://i.imgur.com/36ubms3.png)

## 系统调用

定义：系统在编程时可以调用操作系统的功能

作用：
1、系统调用是操作系统提供给编程人员的唯一接口
2、使CPU的状态从用户态陷入内核态

系统调用、库函数、API、内核函数之间的关系：

应用程序可以直接执行系统调用，但一般应用调用调用C的函数库间接执行系统调用。C函数库是对系统调用的封装。内核函数中只是一部分开放出来允许开发人员进行调用

![](http://i.imgur.com/i5uHNlr.png)

系统调用的执行过程：

当CPU执行到特殊的**陷入指令**时

1、中断/异常机制：硬件保护现场，通过查中断向量表将控制权转给**系统调用总入口程序**
2、系统调用总入口程序：保存线程，将参数保存在内核的栈中，通过查系统调用表把控制权转给相应的系统调用处理
3、执行系统调用
4、恢复现场，返回用户程序

## 存储管理

### 内存划分

内存划分有6种方式，这里只给出3种，另外3种页式、段式、段页式下面介绍

1、单一连续区：一段时间内只有一个进程在内存，简单但内存利用率低
2、固定分区：把内存空间分割成若干区域，每个分区大小可以相同也可以不同，分区大小固定不变，每个分区只能装一个进程
3、可变分区：根据进程的需要，把内存空间空闲分割出一个分区，分配给该进程。缺点是在内存多次内存分配和回收后会留下很多碎片，可以采用紧缩技术解决（采用动态重定向方式时，只需要改变重定向寄存器地址）

记录内存划分结果的**数据结构**：

1、等长划分、单一内存：可以用位图表示，0表示空闲，1表示占用
2、不等长划分

* 空闲区表，每个表项记录空闲的起始地址、长度、标志位（标志是否被分配）。内存回收时，设置标志为0，不进行前后内存合并时，采用空闲区表合适
* 空闲块链，将表项用链表的方式连接起来。当内存回收合并前后内存块时，需要增加、删除表项，使用空闲块链表比较合适

### 内存分配

当一个进程需要分配内存时，采用什么内存分配算法：

1、首次适配：在空闲表中找到第一个满足进程要求的空闲区
2、下次适配：在上次找到的空闲去后接着查找
3、最佳适配：查找整个空闲区表，找到满足进程要求最小的空闲区

内存分配案例：

内存分配是需要维护两个表，分别是空闲区表和已分配表

![](http://i.imgur.com/BThn07F.png)

### 内存回收算法

当某一块归还后，前后空闲空间合并，并修改内存空闲表，分为四种情况：

1、上相邻
2、下相邻
3、上下都相邻
4、上下都不相邻

### 伙伴系统：经典的内存划分、分配、回收算法

主要思想：将内存按照2的幂进行划分，组成若干空闲块链表；查找该链表找到能满足进程需求的最佳匹配块

算法：
1、首先将整个可用空间看做一块
2、如果进程要求分配的大小大于可用空间的一半，小于剩余空间大小，则分配整个块。否则将块划分成两个大小相等的伙伴。一直划分下去，直到产生大于或等于分配大小的最小块

### 地址重定位

逻辑地址：
用户程序中采用的是相对地址的形式，其首地址为0，CPU执行过程中不能通过逻辑地址读取内存中的信息

物理地址：
内存中存储单元的地址，可直接寻址

定义：
CPU执行指令时，将用户程序中的逻辑地址转换为运行时可被直接寻址的物理地址，这一过程称为地址重定向

动态重定向实现：

CPU在执行指令时，逻辑地址加上重定向寄存器中的地址得到物理地址，可被直接寻址

![](http://i.imgur.com/wXDR6dP.png)

### 页式存储

用户进程划分：

* **用户进程地址空间被划分成大小相等部分，称为页或者页面**，从0开始编号
* **内存空间按相同大小划分成大小相等部分，称为块或内存块**，从0开始编号

内存分配：

* 进程划分成若干页，以页为单位分配物理块
* 逻辑相邻的页，物理上不一定相邻

典型页面大小：4K

页表：

**页表记录了页号与物理块的对应关系，每个进程一个页表**

逻辑地址：

**逻辑地址 = 页号（20位） + 页内偏移（4K = 12位）**

**CPU取得逻辑地址，自动划分为页号和页内地址，用页号在页表中查找到物理块，再加上页内地址拼接成物理地址，即物理地址=物理块号+页内便宜**

### 段式存储

作业的地址空间被划分成若干段，如主程序段MAIN、子程序段X、数据段D及栈段S。每个段定义自己的逻辑信息，方便编程

用户进程划分：

* **用户进程地址按程序自身的逻辑关系划分成若干个程序段**，每个程序段都有一个段名
* **内存空间动态划分成若干长度不相同的区域，称为物理段**，每个物理段由起始地址和长度确定

内存分配：
以段为单位进行分配，每段在程序中占据连续空间，但各段之间可以不相邻

段表：

记录了<font color='red'>**段号与物理段首地址及长度**</font>的对应关系，**每个进程一个段表**

![](http://i.imgur.com/2NI45Lm.png)

逻辑地址：

**逻辑地址 = 段号 + 段内偏移**

**CPU取到逻辑地址后，用段号查找段表，得到该段在内存中的起始地址，与段内偏移地址计算出物理地址**

### 段页式存储★★★★★

分页系统能有效提高内存的利用率，而分段系统能很好满足用户需求。段页式存储方式结合了两者的优点

用户进程划分：

* **将用户进程划分为若干段，把每个段划分成若干页**

内存划分：同页式存储管理方案

内存分配：以页为单位进行分配

段表：
用户进程划分为多个段，每个段表示一个逻辑地址区间；**段表记录每一段表包括的逻辑地址范围，用页表地址和页表长度两个表示，引入页表长度防止寻址越界**（段式存储中记录了物理段起始地址和长度，即段表记录的是起始地址+长度）

页表：

**段中的一段逻辑地址区间按照页式存储的方式**，因此需要一张页表，记录页号与物理页的映射关系

综上所述，使用段页式存储管理，**一个进程有一张段表，多个页表**

逻辑地址组成：

![](http://i.imgur.com/GPGvULF.png)

**CPU取到逻辑地址后，获得该地址所在的段号，在段表中查询到页表的起始地址和长度(因为每个段对应一个页表，需要获得页表位置)；根据逻辑地址中的段内页号，查找页表读到该页所在的物理块号；最后用块号+页内地址构成物理地址**

