---
title: 面试总结

date: 2017-07-22 19:07:00

categories:
- 数据结构与算法

tags:
- 面试

---
## Spring：

什么是Spring？
spring是一个轻量级的控制反转（IOC）和面向切面编程（AOP）的框架

什么是IOC/AOP?
IOC是控制反转，就是将创建对象的工作从程序中转移出来，交由Spring框架完成对象的**创建和装配**工作
AOP是面向切面编程，将共有的代码抽离出来，放在一个地方进行维护，在程序运行的时候由框架将切面**切入**到目标对象上，程序员只需要专注业务逻辑的开发

什么是依赖注入？
在创建对象的时候，由框架将依赖的对象实例注入到当前对象中

什么是Bean？
* Spring管理的对象为Bean
* Bean可以是任意对象，包括javabean、service、dao、数据源
* Bean必须由一个无参的构造器，通过get/set方法访问参数，支持序列化

原理：

1、配置文件中定义的 bean 可以全部都可以抽象为一个 Bean 对象，字段包括ID、类名、依赖属性

	<bean id = "person" class = "Person">
		<preperty name = "name" value = "Alan"/>
	</bean>

	=> 抽象

	Bean{
		/* Bean Id */
		private String id;
		/* Bean Class */
		private String type;
		/* Bean Property */
		private Map<String, Object> properties = new HashMap<String, Object>();
	}

2、接下来 Spring 就开始加载我们的配置文件了，将我们配置的信息保存在一个 **HashMap** 中，HashMap 的 key 就是 Bean 的 Id ，HasMap 的value是这个Bean，只有这样我们才能通过context.getBean("user")这个方法获得Animal这个类

3、依赖注入，在实例化一个类时，它通过**反射**调用类中 set 方法将事先保存在 HashMap 中的类属性注入到类中

如何启动Spring？
	
	ApplicationContext context = new ClasspathXMLApplicationContext("application.xml");
	#在web.xml的监听器标签中配置ContextLoaderListener，并在全局参数中配置Spring配置文件
	<listener>  
        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>  
    </listener> 
	<context-param>
		<param-name>contextConfigLocation</param-name>
		<param-value>classpath:applicationContext*.xml</param-value>
	</context-param>

注解依赖注入：

1、注解的方式引入bean：@Service(value = 'a')、@Component(value = 'b')
2、依赖注入：Autoware：按类型；Autoware+Qualifier(value='b')：按名称

AOP：AOP容器会将切面切入到目标对象的连接点上，动态创建一个代理对象供使用者调用

切面：共有功能的实现，包括通知和切入点，如日志切面、事务切面
通知：切面的具体实现，包括前置通知、后置通知、环绕通知、异常通知、最终通知
切入点：定义将通知切入到哪些连接点上

连接点：能够插入切面的地点
目标对象：需要被动态功能加强的对象
代理对象：将切面切入到目标对象后，动态创建的对象

织入：将切面切入到目标对象的连接点上，创建一个新的代理对象的过程

AOP底层实现？
1、JDK动态代理：必须针对接口进行代理，通过Proxy类，传入类加载器、接口和InvocationHandler类，返回代理对象
2、CGLIB：如果目标对象没有接口，无法使用JDK动态代理，则可以使用CGLIB

动态代理原理：

* 使用：1、创建目标对象 2、自定义类实现InvocationHandler接口，构造函数中传入目标对象，在实现的接口方法Invoke中对根据选择对方法进行代理 3、调用Proxy.newProxyInstance方法中传入是三个参数，分别是类加载器，代理的接口和自定义InvocationHandler实例，返回代理对象
* 原理：1、调用ProxyGenerator的generateProxyClass方法产生ProxySubject.class的二进制数据，**代理类实现接口中的方法，方法体中都是调用成员变量InvocationHandler的invoke方法**，需要传入参数类名和实现接口，生成的代理类在调用接口方法时，会调用传入的InvocationHandler的invoke方法 2、利用反射创建代理对象的实例，并且传入InvocationHandler参数，返回代理对象实例 3、**执行代理类的对象时都会执行InvocationHandler的invoke方法**

基于注解的AOP：AspectJ

1、开启注解`<aop:aspectj-autoproxy/>`
1、定义一个类作为切面，用@Aspect注解，并在配置文件中配置切面
2、定义切入点和通知

环绕通知和前置、后置区别：
spring 的环绕通知和前置通知，后置通知有着很大的区别，主要有两个重要的区别：

1） **目标方法的调用由环绕通知决定**，即你可以决定是否调用目标方法，而前置和后置通知是不能决定的，他们只是在方法的调用前后执行通知而已，即目标方法肯定是要执行的。

2）  环绕通知可以控制返回对象，即你可以返回一个与目标对象完全不同的返回值，虽然这很危险，但是你却可以办到。而后置方法是无法办到的，因为他是在目标方法返回值后调用

**总结**：1、前置通知是在方法调用前执行，后置通知在方法调用后执行，但是方法都必须执行，但环绕通知可以决定是否调用该方法 2、环绕通知可以修改方法的返回值，但后置通知办不到，因为他是在目标方法返回值后调用

通知执行顺序：

	·环绕前置通知
	
	前置通知
	
	具体业务方法
	异常通知
	
	·环绕后置通知
	
	后置通知

当目标方法抛出异常时，后置方法不再执行

## Spring MVC：

什么是Spring MVC？
Spring MVC是一个基于MVC设计理念的web框架

SpringMVC运行原理：
1、DispatcherServlet 拦截所有请求
2、从HandlerMapping 查找 Handler，返回执行链（Handler和拦截器集合）
3、DispatcherServlet 调用 HandlerAdapter，HandlerAdapter 调用 Handler，**Handler处理具体的业务逻辑**。Handler处理完业务逻辑后返回ModelAndView给HandlerAdapter，其中View是视图名称，Modal是数据模型。HandlerAdapter再返回给DispatcherServlet。
4、DispatcherServlet通过ModelView的**视图名称**在视图解析器中查找视图，视图解析器返回真正的View视图对象
5、渲染视图

HandlerMapping作用？

RequestMappingHandlerMapping处理**请求映射**的，根据用户的请求URL，查找@RequestMapping，找出匹配的Handler（**URL->Handler**）

HandlerAdapter作用？

HandlerAdapter的handler**方法处理注解和准备handler方法中的参数**（这就是SpringMVC如何将request中的参数编程输入参数的地方），最终**调用实际的Handler method**

Restful风格API？

（1）每一个URI代表一种资源(只能有名词)
（2）客户端通过四个HTTP动词(get/post/put/delete)，对服务器端资源进行操作
（3）客户端和服务器之间，传递这种资源的某种表现层

url示例：

	get /board/xxxx.html  
	post /board?title=xx
	delete /board?id=xxx
	put /board?id=xx&title=xx

API:

	@Requestmapping(value = "/board/{id}.html" method = RequestMethod.GET)
	public String getBoard(@Pathvariable("id") String id){
		server.get(id);
	}


消息转换：

使用：
用@RequestBody标注，并在Domain对象中标注注解@XmlRootElement，将XML字符串转换为Domain对象
用@ResponseBody标注，将

原理：

HttpMessageConvert 自动将http消息转化为对象，将对象转化http消息

1、Spring MVC 配置了默认转换器，在类加载的时候尝试加载一些默认转换类，如jackson、jaxb，如果加载抛出异常说明没有引入类，否则来实例化响应的消息转换器类。当返回 HandlerAdapter时，为之设置**转换器列表**
2、根据请求体的类型，如text/xml，遍历所有的消息转换器，看是否支持请求体类型；最终调用jaxb消息转换器，进行转换

**WebMvcConfigurationSupport：Spring MVC主要配置类**，包括messageConverters、url匹配等

为什么转化为XML而不是JSON？

## mybatis

![](http://i.imgur.com/JpGhPj9.jpg)

mybatis优势：

## 什么是SOA？

面向服务的架构，强调的是一种架构思想，将系统划分为多个模块，各模块之间以标准服务的方式进行交互，强调组件化的灵活开发方式

（将系统划分为多个模块，也称为服务，这些服务之间通过接口和协议联系起来，接在一起以实现特定的功能。）

## 什么是RPC框架？

RPC框架：远程过程调用协议，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议

http://www.jianshu.com/p/0f4113d6ec4b

## 什么是Thrifit：

**Thrift最初由Facebook研发，主要用于各个服务之间的RPC通信，采用接口描述语言定义服务，支持跨语言，数据传输采用二进制，能够快速构建服务**

接口描述语言：
客户端和服务端能使用不同的语言开发，那么一定就要有一种中间语言来关联客户端和服务端的语言，没错，这种语言就是IDL（Interface Description Language）。

基本数据类型：

* byte: 有符号字节 
* i16: 16位有符号整数 
* i32: 32位有符号整数 
* i64: 64位有符号整数 
* double: 64位浮点数 
* string: 字符串

容器类型：

* list<T>: 一系列由T类型的数据组成的有序列表，元素可以重复
* set<T>: 一系列由T类型的数据组成的无序集合，元素不可重复
* map<K, V>: 一个字典结构，key为K类型，value为V类型，相当于Java中的HMap<K,V>

结构体：（记得写参数编号）

	struct People {
	     1: string name;
	     2: i32 age;
	     3: string sex;
	}

枚举(enum)：

	enum Sex {
	    MALE,
	    FEMALE
	}

异常(exception)：

	exception RequestException {
	    1: i32 code;
	    2: string reason;
	}

服务(service):thrift定义服务相当于Java中创建Interface一样，创建的service经过代码生成命令之后就会生成客户端和服务端的框架代码

	service HelloWordService {
	     // service中定义的函数，相当于Java interface中定义的函数
	     string doAction(1: string name, 2: i32 age);
	 }

注释：thrift注释方式支持shell风格的注释，支持C/C++风格的注释，即#和//开头的语句都单当做注释，/**/包裹的语句也是注释。

服务描述文件示例：

	namespace java com.winwill.thrift
	
	enum RequestType {
	    SAY_HELLO,   //问好
	    QUERY_TIME,  //询问时间
	}
	
	struct Request {
	    1: required RequestType type;  // 请求的类型，必选
	    2: required string name;       // 发起请求的人的名字，必选
	    3: optional i32 age;           // 发起请求的人的年龄，可选
	}
	
	exception RequestException {
	    1: required i32 code;
	    2: optional string reason;
	}
	
	// 服务名（类似于接口名）
	service HelloWordService {
	    string doAction(1: Request request) throws (1:RequestException qe); // 可能抛出异常。
	}

**使用Thrift开发流程为**：

* 编写接口文件（IDL：Interface Description Language）
* 经过Thrift工具编译后，生成一个个Java类
* 实现Service类

**Thrift框架原理**;

* 服务器启动后处于监听状态，当接收到客户端的消息后，服务器发起一个线程处理该消息请求，原线程再次进入阻塞状态
* 新线程根据协议读取消息，调用请求方法，并将结果写入到结果，传回客户端

**Thrift传输协议**：
协议类别总体上划分为：文本、二进制，但为节省带宽，提高传输效率，一般使用二进制类型的传输协议

**Thrift客户端、服务端**：
有阻塞，非阻塞，线程池，半同步半异步，Selector多种服务端实现模式。

	TSimpleServer – 简单的单线程服务模型，常用于测试
	TThreadedServer – 多线程服务模型，使用阻塞式IO，每个请求创建一个线程。(java 不支持)
	TThreadPoolServer – 多线程服务模型，使用标准的阻塞式IO，预先创建一组线程处理请求。
	TThreadedSelectorServer 允许你用多个线程来处理网络I/O。它维护了两个线程池，一个用来处理网络I/O，另一个用来进行请求的处理
	TNonblockingServer – 多线程服务模型，使用非阻塞式IO（需使用TFramedTransport数据传输方式）,只有一个线程来处理消息
	THsHaServer - 半同步半异步的服务模型，一个单独的线程用来处理网络I/O，一个worker线程池用来进行消息的处理

客户端包括同步，异步两种形式

**Thrifit优势**：
使用二进制数据格式传输，

JSP：Java Servlet Page 动态生成网页的技术
在第一次访问JSP的时候，会将JSP文件翻译成一个Servlet文件，然后将Servlet编译成class文件，并加载进内存，创建一个Servlet实例，调用其init方法，其中init方法只有在第一次访问时调用，然后调用其service方法。第二次之后直接访问其service方法，所以第一次加载速度比较慢，之后就比较快了

```
<c:forEach items="${a}" var="fuwa">
     <c:out value="${fuwa}"/><br>
</c:forEach>
```

内置对象：request、response、session、application、page、out、config、exception、pageContext

装修计算器：主要有两大功能，装修规划及预算报价，

mybatis：

## 园区网用户行为审计系统

项目介绍：本项目为解决园区网络内部的安全问题，对园区网络的内网用户访问外部网络的行为进行监控和审计，并将网络上发生的事件记录下来以便事后追查
主要负责：

1、利用华为二层、三层交换机组建园区网络：接入层采用二层交换机，骨干网采用高性能的三层交换机，在二层交换机中划分VLAN，隔离广播域（VLAN是虚拟的局域网）。在三层交换机配置SVI接口，在能够实现不同VLAN之间的通信（不同VLAN之间的通信相当于不同的广播域进行通信，要采用路由的方式，三层交换机一般处于骨干网络，能够记录下IP地址与交换机端口之间的映射关系，在园区网络内实现互联互通）

2、基于SNMP协议审计虚假路由攻击：实时监测园区网络中路由表的变化，SNMP是简单网络管理协议，可以获得设备的基本信息；使用UDP作为传输层；用161端口接收get/set报文，用162接收trap报文；当系统启动时主动获取路由器中的路由表，当路由表发生变化时，会向管理主机发送一个trap报文，查询路由表并与之间的对比，如果路由表发生变化则认为发生虚假路由攻击

3、利用Jpcap抓包对网络流量监控：Java语言对网络层以下的控制无能为力，Jpcap是一个中间件，JPCAP调用wincap，对数据链路层的控制；利用Java第三方类库Jpcap抓取网络数据包，统计单位时间网络传输的字节速率，具体方案是维护{bytes = 0，开始时间}，当时间小于一秒钟，累计字节数；如果超过1秒就记录下当时的字节数，得到的结果就是一秒内传输的字节速率

这是一个**网络监控软件**，解析各种常见的协议，如HTTP、SMTP、Telnet等，分析用户行为，能够知道用户在什么时候做了什么事情；

整个系统分为多个模块，每个模块是一个线程，各个模块间通过队列的方式协调运行
1、采集模块：因为 Java 程序没法操作链路层，所以采用 JPCAP 中间件从底层抓取数据包，放到队列中
2、分派模块：分派模块根据不同的数据包类型，将TCP数据包放到TCP队列，UDP数据包放到UDP队列，ARP数据包放到ARP队列
4、TCP重组模块：从TCP队列中取出数据包，根据TCP重组算法建立完整的TCP会话连接，并放入解析队列
4、解析模块：从解析队列中取出数据，根据使用的端口，进行协议解析：如果80端口解析HTTP报文，25端口是SMTP协议，110是POP3协议

TCP重组算法：根据源地址、目的地址、源端口、目的端口确定一条TCP连接，从TCP三次握手开始到TCP四次挥手，维护客户端和服务器的状态机，当出现SYN数据包时，客户端的状态由关闭状态变为SYN Send，当接收到 SYN+ACK，服务器端的状态由监听状态变为SYN Received；当接收到ACK，客户端的状态变为Established，服务器端的状态变为Established。之后接收到数据包，如果正式当前缓存队列中期待的数据包，则加入队列，否则放入乱序的队列；接下来到四次挥手，当接收到Fin数据包，客户端的状态变为Fin Wait1，接受都 Fin+ACK 服务器端的状态变为Close Wait;当接收到服务器端的Fin，服务器的状态变为Last ACK，当接收到ACK时，客户端的状态变为Fin Wait2

### JVM性能调优

1、jstat -gcutil 首先看存在占用100%或90以上的，增大堆3g -Xms -Xmx
2、可能会太大了，回缩，jstat -gc 设置堆为老年堆占用量的4倍
3、设置新生代和持久代为老年堆使用量的1.5倍
-Xmn
-XX:PermSize
-XX:MaxPermSize

## 热点 POI 预测

近期新增的 POI 中筛选出一批数据，预测其在未来的一段时间内会成为热点数据，并且这些POI是错误的，这样可以在这些POI累计到一定量前，及时发现并进行修正，减少对用户的伤害

指标：
1、错误率：预测出的POI是错误的
2、热度：如果这个POI是错误的，但是如果热度不高，这些POI不为用户所知，即使POI是错的，对用户影响也不大，工作意义不大。所以需要保证热度

如何从热度从50%上升到70%？
之前以历史三天的作为参考，后来以历史7天的作为参考

如何从错误率从20%上升到40%？
筛掉可信源，包括众包，室内地图；还有多来源，并且提供坐标

## 计算机网络

**三次握手**

![](http://i.imgur.com/vwU8xop.png)

首先客户端向服务端发送SYN报文（seq = client_isn），服务端收到后发送ACK（client_isn+1），和SYN报文（seq = server_isn），客户端再发送ACK（server_isn+1），TCP连接建立

当双方建立 TCP 连接以后，就可以传输数据了，传输过程中发送方每发送一个数据包 ，接收方都要给予一个应答。

TCP 断开连接
建立一个连接需要 3 次握手，而终止一个连接要经过 4 次握手（如图 2 ）。**这是因为一个 TCP 连接是全双工（即数据在两个方向上能同时传递），每个方向必须单独地进行关闭**。4 次握手实际上就是双方单独关闭的过程。

**为什么是三次握手，二次可以吗？**

三次握手的核心是什么？<font color='red'>**三次握手是为了交换客户端和服务器各自的初始序列号，这样双方都知道对方的初始序列，从而判断哪些TCP数据包是合法的，哪些不合法**</font>

两次握手的时候，客户端向服务器端发送同步包。服务器接收到后，**知道客户端的初始序列**，分配资源建立连接，发送同步包和确认包，客户端接收到后，**知道服务器的初始序列**，于是分配资源连接建立，**正常情况下是没有问题的**

**可能服务器发送的ACK丢失**，客户端以为服务器没有接收到SYN，然后重新发送同步报，但是**此时服务器已经打开连接了，会忽略客户端发送的同步包**，这样客户端就永远不会获得服务器端的初始序列号，两者无法建立连接，但服务器端已经分配了资源，从而造成资源浪费

采用三次握手的时候，当接收到客户端的同步包的时候，建立半连接，当接收到客户端的响应时才打开连接
<br/>
<font color='red'>**此时如果客户端打开连接了，但是第三次ACK丢了，会造成客户端的资源浪费吗？**</font>

服务器会重新发送SYN+ACK，直到接收到ACK，这样客户端和服务器都建立了连接，**不会造成任何一方的资源浪费**

**为什么不是四次握手？**

三次握手已经能够建立可靠连接，第四次握手就多余了，<font color='red'>**在通信理论上，三次握手是不可靠信道上，进行建立可靠连接的最小次数**</font>，所以采用过三次握手可以提高连接的效率

**四次挥手**

FIN-ACK-FIN-ACK
客户端状态：Fin-Wait1，Fin-Wait2，Time-Wait，close
服务器状态：Clost-Wait，Last-ACK，close

![](http://i.imgur.com/JnAoPIc.jpg)

**TCP细节：**

发送缓存：

[0，base-1]内的序号已经发送并确认过的序列，[base，nextSeqnum-1]对应已经发送但未被确认的分组，[nextSeqnum，base+N-1]内的序号为要被立刻发送的分组，数据来自上层，大于bast+N的序号不能使用，直到流水线中未被确认的分组得到确认为止

![](http://i.imgur.com/CeJwtVf.png)

回退N步（GBN）：

* 发送方如果出现超时事件，将重传所有**已发送但未被确认的分组**
* 接收方需要维护下一个按需接收的分组序号，如果按序到达，将数据提交给上层；如果失序，直接丢弃，不进行任何缓存

选择重传：

* 每个分组发送后启动定时器，发送方会重传未被确认分组中序列号最小的的分组
* 在接受方失序的分组将被缓存

TCP可靠数据传输：

发送方：1、从上层应用程序接收数据 2、定时器超时 3、收到ACK报文

发送数据包时启动定时器；定时器超时，重发未被确认分组中序列号最小的分组，并开启定时器；接收到ACK，而且ACK大于当前未被确认的序列，更新已经确认的序列，重启定时器；如果小于的话，直接忽略

![](http://i.imgur.com/mGghHta.png)

## 公众号开发

项目介绍：马可波罗瓷砖莞深销售中心公众号，用于解决分公司日常的**销售业务中**存在大量的信息沟通需要

### 编码转换（已删）

utf8-latin1-gbk

String content content = new String(temp.getBytes("gbk"),"iso-8859-1");

问题转换为如何将gbk编码的字节正确传输；
1、new String(temp.getBytes("gbk"),"iso-8859-1")：获得gbk编码的字节流，用lain1字节解码，获得字符串，任务转换为传输该字符串，只要发送方和接收方一致就行，
2、接收方接收到字节流，直接用gbk解码

### RedisTemplate

1、底层采用Jedis访问redis，包括一些set/get/expire命令
2、RedisTemplate 加上一层连接池
3、对于每次操作都是打开链接，执行操作；为了简洁，设计成execute（callback）的方式，不同的操作只是callback中的内容不一样
4、使用jdk序列化工作执行对象的序列化

### 动态数据源切换

之前开发了一个微信公众号，后来提出了一个需求，需要开发5个分公司的微信公众号，有两种方案：

1、每个公众号设置不同的端口运行在服务器上，反向代理根据域名定位到个自己的服务器上
2、使用同一个应用，根据不同的公众号，动态切换数据源

由于每个公众号采用的操作都是一样的，就是数据不一样，于是采用方案二

如何分别不同的公众号？两种方案：

1、采用一级域名，二级域名的方式
/mk/bu1/o/get=>相当于寻找/bu1/o/get，找不到
重定向带/o/get => 原来的不用改

2、采用标记

公众号1：flag = 1
公众号2：flag = 2

因为微信重定向时只能带一个参数，所以采用一级、二级域名的方式

具体方案：

1、重写DispatcherServlet的doDispatch方法，利用线程局部变量ThreadLocal记录前缀，然后重定向

2、继承AbstractRoutingDataSource，重写determineCurrentLookupKey的方法，这个方法在调用数据源的getConnection方法时需要选择数据源的名称，这是我们返回ThreadLocal的值就行了，完成了动态数据源

在Spring中配置数据源时，对应的class是咱么自己重写的数据源，然后改数据源管理了一些需要切换的数据源，用map保存

源码分析：http://www.cnblogs.com/davidwang456/p/4318303.html#top

## 数据结构与算法

单向链表头插法：

	t = first;
	first = new Node();
	first.next = t;

这种写法对first是否为null都不影响，但是对last指针有影响：当first为空时，last=first，否则last不变，完整写法：

	t = first;
	first = new Node();
	first.next = t;
	if(t == null){
		last = first;
	}else{
		//不操作
	}

双向链表头插法：

不考虑特殊情况的写法：

	t = first;
	first = new Node();
	first.next = t;
	first.pre = null;
	t.pre = first;

但当first为null的时候，t.pre=first会报空指针异常，修正：

	t = first;
	first = new Node();
	first.next = t;
	first.pre = null;
	if(t == null){
		last = first;
	}else{
		t.pre = first;
	}

总结：头插法和尾插法思考方法
1、保存first或last的指针
2、first或last指向新new出来的对象，维护其与前后节点之间的关系
3、当first或last为空时，分别使last或first执行new的对象，如果是双向链表，还需维持new出来对象前后之间的关联

头插法双向链表：

	private void linkFirst(E e) {
	    final Node<E> f = first;
	    final Node<E> newNode = new Node<>(null, e, f);
	    first = newNode;
		//易错点
	    if (f == null)
	        last = newNode;
	    else
	        f.prev = newNode;
	    size++;
	    modCount++;
	}

尾插法双向链表：

	void linkLast(E e) {
	    final Node<E> l = last;
	    final Node<E> newNode = new Node<>(l, e, null);
	    last = newNode;
		//易错点
	    if (l == null)
	        first = newNode;
	    else
	        l.next = newNode;
	    size++;
	    modCount++;
	}

## Thrift

http://www.jianshu.com/p/0f4113d6ec4b#

Thrift最初由Facebook研发，主要用于各个服务之间的RPC通信，支持跨语言

既然客户端和服务端能使用不同的语言开发，那么一定就要有一种**中间语言**来关联客户端和服务端的语言，没错，这种语言就是IDL（Interface Description Language）**接口描述语言**

支持数据类型：

* byte: 有符号字节
* i16: 16位有符号整数
* i32: 32位有符号整数
* i64: 64位有符号整数
* double: 64位浮点数
* string: 字符串

结构体

	struct People {
	     1: string name;
	     2: i32 age;
	     3: string sex;
	}

异常

	exception RequestException {
	    1: i32 code;
	    2: string reason;
	}


## OOP三大特性：继承，多态，封装，抽象

记忆：jdcf
（京东程飞）

### 继承

http://yunnigu.dropsec.xyz/2016/09/25/Java%E4%B9%8B%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99%E4%B8%8E%E5%B1%9E%E6%80%A7%E8%A6%86%E7%9B%96/#

在父类中定义这些相同的当多个类存在相同的**属性和方法**，所有的子类不需要重新定义这些属性和方法，只需要继承父类,这样子类就会自动拥有父类定义的某些属性和方法

1、Java继承中的属性覆盖

父类哪些属性、方法被子类继？**除了private修饰的属性和方法都能都能被子类继承**

继承中的属性覆盖结论：

* 由于private变量受访问权限的限制，它不能被覆盖
* 属性的值取父类还是子类并不取决于我们创建对象的类型，而是取决于我们**定义的变量的类型**
* friendly、protected和public修饰符并不影响属性的覆盖
* **静态变量和静态常量属于类，不属于对象，因此它们不能被覆盖**
* **常量可以被覆盖**
* 对于基本类型和对象，它们适用同样的覆盖规律

2、Java方法重写

* 重载时只与**方法特征**有关，重写时会进一步检查两个方法的**返回类型**是否相同、**访问修饰**权限是否缩小和抛出的**异常范围**是否扩大
* 非私有非静态方法不能被任何静态方法覆写
* 非私有静态方法不能被任何非静态方法覆写
* 子类与父类中**有方法特征相同的静态方法时**，覆写规则与非静态方法覆写规则一样，但一般我们不把静态方法的覆写叫覆写，虽然语法规则上与非静态方法相同。**不存在多态**
* 私有方法对子类同名方法不产生任何影响，也就是说私有方法不能被重写，即使试着在子类覆写了父类的私有方法，不管访问权限修饰符是什么，在编译时也不会报错。原因就是私有方法对子类也是不可见的。


### 多态

就是指一个引用(类型)在不同情况下的多种状态，实现多态有两种方式：**1、继承；2、接口**

方法重写与方法重载：

* **方法重载**：在一个类中有多个<font color='red'>**相同名字**</font>的方法，但具有<font color='red'>**不同的参数表**</font>（参数类型、个数、顺序），**返回值类型、方法的修饰符可以不同，如果只是返回类型或方法的修饰符不一样，不能构成重载**，，调用方法时通过传递给它们的不同参数个数和参数类型来决定具体使用哪个方法, 这就是多态性。
* **方法重写**： **子类**有一个方法，和**父类**的某个方法的**返回类型、方法名、参数表一样**，子类方法不能缩小父类方法的<font color='red'>**访问权限**</font>，可以放大访问权限；**不能扩大异常范围，可以不抛异常**                                                    

### 抽象

定义一个类时候，实际上就是把一类事物的共有的属性和行为提取出来，形成一个类

### 封装

封装就是把抽象出来的**数据**和对数据的**操作**封装在一起。数据被保护在内部，程序的其它部分只有通过被授权的操作(**成员方法**)，才能对数据进行操作。

访问控制修饰符

![这里写图片描述](http://img.blog.csdn.net/20160416152720709)

## 设计模式

### 设计模式原则

总的原则：可维护，复用，易扩展

SOLIDcl：（泥土 蔡磊）
s单一职责原则
o开闭原则：对扩展开放，对修改关闭
l里式替换：父类可以引用子类
i接口隔离原则：使用多个专门的接口，而不是用单一的总接口
d依赖倒转：面向接口编程
c合成复用：尽量使用对象组合，而不是继承达到复用的目的
l迪米特：一个软件实体尽可能少与其他实体耦合                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      

### 单例模式：确保一个类只有一个实例

1、构造方法私有，外部不能通过new创建对象
2、静态变量保存唯一实例
3、静态的getInstance方法，是外部能够访问

饿汉模式:在类加载的时候已经创建了单例对象

	//staic final静态常量
	private static final Singleton instance = new Singleton();
	private Singleton(){}
	public static Singleton getInstance(){return instance;}

懒汉模式：第一次调用的时候创建对象实例


	private static Singleton instatnce = null;
	private Singleton(){}
	//注意同步控制关键字 Synchronized
	synchronized public Singleton getInstance(){
		if(instance == null){
			instance = new Singleton();
		}
		return instance;
	}

方法二：synchronized同步控制代码块，双重检查锁定（单次判断实例不为空，如果一个线程正在创建对象但还未创建完成，另一个线程进入实例不为空的判断，最终产生两个实例，未被单一对象的原则）

	//使用volatile保证可见性
	private volatile static Singleton instatnce = null;
	private Singleton(){}
	public static Singleton getInstance(){
		//第一重判断
		if(instance == null){
			synchronized(Singleton.class){
				//第二重判断
				if(instance == null){
						instance = new Singleton();
				}
			}
		}
		return instance;
	}

为什么需要使用volatile？不是同步快结束完之后，会将instance对象写入内存？

答：主要在于instance = new Singleton()这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情。

* 给 instance 分配内存
* 调用 Singleton 的构造函数来初始化成员变量
* 将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了）

但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。

<font color='red'>**解析**：</font>

	线程1创建调用getInstance（）方法执行到instance=new Singleton()，但是这条语句不是原子性的，他分为三个步骤：1、分配内存 2、初始化 3、instance对象指向内存空间，执行完这步后instance为非空了。

	但是jvm存在指令重排序的优化，如果指令按照1，3，2的执行方式，但是线程1在执行3之后，但未执行2之前，此时instance已经不为null了，这时候线程2调用getInstance（）方法（注意这时线程2可以调拥这个方法，因为只有进入一重检查锁之后才是临界区。）执行第一重判断if(instance == null){，此时instance不为null，直接调用return instance语句返回对象，但对象并没有真正得实例化完毕，调用就会出现错误

我们只需要将 instance 变量声明成 volatile 就可以了。

有些人认为使用 volatile 的原因是**可见性**，也就是可以保证线程在本地不会存有 instance 的副本，每次都是去主内存中读取。但其实是不对的。使用 volatile 的主要原因是其另一个特性：**禁止指令重排序优化**。也就是说，在 volatile 变量的**赋值操作后面会有一个内存屏障**（生成的汇编代码上），读操作不会被重排序到内存屏障之前。比如上面的例子，**读操作必须在执行完 1-2-3 之后或者 1-3-2 之后，不存在执行到 1-3 然后取到值的情况。**从「先行发生原则」的角度理解的话，就是对于一个 volatile 变量的写操作都先行发生于后面对这个变量的读操作（这里的“后面”是时间上的先后顺序）。


方法三（最优）：静态内部类中保持对象的实例，在第一次调用的时候创建单例对象

	private static class Hold{
		private static final Singleton instance = new Singleton();
	}
	private Singleton(){}
	
	public static Singleton getInstance(){
		return Hold.inistance;
	}

饿汉式和懒汉式对比：饿汉式在类加载的时候创建，不管用不用，都占据内存；懒汉式在第一次使用的时候创建，必须加锁，多线程时性能受影响

### 集中式工厂——简单工厂模式

定义**产品接口**，**抽象产品类**实现接口，加入一些共有方法和抽象方法，**具体产品**类继承抽象产品类，实现方法

工厂类包括一个**静态的getProduct方法，参数为具体产品名，返回值为产品接口**，根据传入的产品名，返回不同的具体产品类

调用方法:

	Product a = Factory.getInstance("A");
	Product b = Factory.getInstance("B");

缺点：增加一个新的产品时必须修改工厂类

### 多台工厂——工厂方法模式


定义**产品接口**，**抽象产品类**实现接口，加入一些共有方法和抽象方法，**具体产品**类继承抽象产品类，实现方法

定义工厂接口，有个一getInstance方法。**对于每一个具体的产品，都对应一个具体的工厂类**，重新getInstance方法中实例化具体产品

调用方法：

	Factory factory = new AFactory();
	ProductA = (ProductA)factory.getInstance();

缺点：每个工厂只生产一种产品，工厂类太多

### 产品族的创建——抽象工厂

相关的产品组成一个"产品族"，由同一个工厂来统一生产

1、工厂方法中有多个方法，用来创建不同的产品

	public interfact Factory{
		ProductA createA();
		ProductB createB();
	}

2、对于一个产品族，对应一个具体的工厂方法

	class SpringFactory implements Factory{
		ProductA createA(){return new SpringProductA();}
		ProductB createB(){return new SpringProductB();}
	}

	class SummerFactory implements Factory{
		ProductA createA(){return new SummerProductA();}
		ProductB createB(){return new SummerProductB();}
	}

### 外观模式

n客户端通过一个**统一的外观角色**与子系统进行通信，降低客户端的使用难度

外观类接收客户端的请求，并将请求委派到相应的子系统中处理，最终返回结果

具体实现：外观类中保持自己子系统的

### 观察者模式

### 代理模式

## Linux命令：

wget  要下载文件的url
tail 查看日志
tar -zxvf 解压
zip xx 压缩

mount  挂载
unmount 卸载

make 根据makefile进行编译
make install 根据makefile进行安装

rpm 查看软件

yum install 安装软件

mkdir 建立文件夹
rmdir 删除空文件
rm -rf 删除文件夹

mv 移动
cp 复制

netstat -anp | grep 8080 查询端口

sudo 命令/ sudo su #管理员权限

service mysqld start 启动mysql数据库
service mysqld stop 停止

ps -aux 进程列表
kill -9 pid 杀进程

权限：
chmod 777 文件名 #！！！！！！！！！！
chown 用户名 文件名 #修改文件所有者
chgrp 组名 文件名 #修改文件所有组

/etc/profile #系统整体配置文件

df 系统分区情况

## 数据库

### 数据库优化方案

单机：
（单从数据库本身）
Mysql换成Oracle，因为Oracle具有更大的存储空间，更安全，稳定
表优化：大表变小表，分库分表

（数据库之上）
读写分离：主从数据库

数据库连接池

（引入缓存）
缓存

分布式
集群+负载均衡：mysql集群、数据库操作中间件、redis集群

### 连接池

连接池的作用：

* 用户请求一次查询的时候就会向数据库发起一次连接，执行完后就断开连接，而创建连接、释放连接都很耗费资源和时间，**数据库的连接资源并没有得到很好的重复利用**。使用连接池后直接从连接池中获取已经创建的连接，使用完之后放回连接池中
* 如果有很多用户同时在线，开发者不好控制数据库的连接数，很有可能因为分配的连接过多而导致内存耗尽。使用连接池可以控制最小连接数、最大连接数，可以根据连接的使用率进行增大或减少

### 数据库引擎

Mysql中MyISAM引擎和InnoDB引擎的比较

* 事务：InnoDB类型支持事务等高级处理，MyISAM不支持
* 并发：在执行数据库写入的操作（insert,update,delete）的时候，mysiam表会锁表，而innodb表会锁行
* 查询速度：MyISAM记录行数

选择：

* MyISAM适合：(1)做很多count 的计算；(2)**插入不频繁，查询非常频繁**；(3)没有事务。
* InnoDB适合：(1)可靠性要求比较高，或者要求事务；(2)**表更新和查询都相当的频繁**，并且表锁定的机会比较大的情况。

## Java基础

### intern方法

解法：new string的都是指向堆中的地址，intern返回的都是常量池记录的地址，**但要注意常量池的地址是否是指向堆中的地址；**只有第一次通过new String创建某一字符串时，而之前这个字符串没有以**字符串常量的形式（引号的形式）**放入常量池，那么常量池将会引用第一次new String时指向堆的地址

小心：
JDK1.6之前保存的都是字符串的字面值
JDK1.7之后可能会保存字符串的引用

实例：

1、调用toString（内部是调用new String的方式）之前常量池没有计算机软件变量，所以调用new String时放入常量池，常量池中的字符串指向堆中的地址

	String s = new StringBuilder("计算机").append("软件").toString();
	System.out.println(s.intern() == s);//返回true

2、"计算机软件"放入常量池，调用toString时发现常量池已经存在该字符，不放入常量池

	String s = new StringBuilder("计算机软件").toString();
	System.out.println(s.intern() == s);//返回false

3、常量池计算机软件指向的是第一次new String时堆中的地址，即s1的地址；s2又是一个新的地址，所以第二个返回false

	String s1 = new StringBuilder("计算机").append("软件").toString();
	String s2 = new StringBuilder("计算机").append("软件").toString();
	System.out.println(s1.intern() == s1);//返回true
	System.out.println(s2.intern() == s2);//返回false

参考
http://blog.csdn.net/u013066244/article/details/53575281
http://blog.csdn.net/u010697982/article/details/45696989

### 注解

注解作用：

* 生成文档，通过代码里标识的元数据生成javadoc文档。
* **编译**检查，通过代码里标识的元数据让编译器在编译期间进行检查验证。
* **编译时动态处理**，编译时通过代码里标识的元数据动态处理，例如**动态生成代码**。
* **运行时动态处理**，运行时通过代码里标识的元数据动态处理，例如**使用反射注入实例**。

元注释：

@Retention用于标明注解被保留的阶段
* SOURCE：被编译器丢弃 ——> 编译检查、生成doc文档
* CLASS：被编译器写入class文件中，但虚拟机无法获取到 ——> 动态生成代码
* RUNTIME：被编译器写入class文件中，运行时通过反射访问 ——> 依赖注入


@Target用于标明注解使用的范围
* TYPE：类、接口、枚举
* FLED：成员变量
* METHOD：方法
* PARAMETER：方法参数
* CONSTRUCTOR：构造器
* LOCAL_VARIABLE：局部变量
* ANNOTATION_TYPE：注解类型
* PACKAGE：包

@Inherited用于标明注解可继承，@Documented用于标明是否生成javadoc文档。

注解原理：

1、注解是在编译时由**编译器**进行处理，编译器会对注解符号处理并附加到**class**结构中
2、通过反射方法 Class.getAnnotation(Test.class) 获取到 Test 注解对象，进而再通过Test注解对象获取到Test里面的属性值

	Test.java
	@Target({ElementType.TYPE})
	@Retention(RetentionPolicy.RUNTIME)
	public @interface Test {
	    String value();
	}
	
	Main.java
	@Test(value = "qm")
	public class Main {
	    public static void main(String[] args) throws ClassNotFoundException {
	        Class<?> clazz = Class.forName("Annotation.Main");
	        Test annotation = clazz.getAnnotation(Test.class);
	        System.out.println(annotation.value());
	    }
	}

注解对象是什么？
其实注解被编译后的**本质就是一个继承 Annotation 接口的接口**，所以@Test其实就是"public interface Test extends Annotation"，当我们通过AnnotationTest.class.getAnnotation(Test.class)调用时，**JDK会通过动态代理生成一个实现了Test接口的对象，并把将RuntimeVisibleAnnotations属性值设置进此对象中**，此对象即为Test注解对象，通过它的value()方法就可以获取到注解值。

### Java中static作用

static表示"全局"或者"静态"的意思，用来修饰**成员变量**和**成员方法**，也可以形成静态**static代码块**，但是Java语言中没有全局变量的概念

被static修饰的成员变量和成员方法**独立于该类的任何对象，被类的所有实例共享**。

**public修饰的static成员变量和成员方法本质是全局变量和全局方法**，当声明它类的对象市，不生成static变量的副本，而是类的所有实例共享同一个static变量。

static变量前可以有**private修饰**，表示这个变量可以在**类的静态代码块中，或者类的其他静态成员方法中使用**（当然也可以在非静态成员方法中使用--废话），但是**不能在其他类中通过类名来直接引用**，这一点很重要

总结：

* static表示静态的，修饰变量、方法后叫做静态变量和静态方法，**在加载类的过程中完成静态变量的内存分配**，为所有对象所共有，通过类直接方法
* static块在类加载的时候执行      
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  
## HashMap底层

http://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/

定义：

	基于Map接口实现、允许null键/值、非同步、不保证有序(比如插入的顺序)、也不保证序不随时间变化。

记忆：定义（Map接口）、特点（无序、null）、线程同步（非同步）

两个重要的参数：容量(Capacity)和负载因子(Load factor)

	简单的说，Capacity就是bucket的大小，Load factor就是bucket填满程度的最大比例。如果对迭代性能要求很高的话不要把capacity设置过大，也不要把load factor设置过小。当bucket中的entries的数目大于capacity*load factor时就需要调整bucket的大小为当前的2倍。

记忆：容量（桶的数量）、负载因子（衡量桶装满程度，当桶中的entries的数目大于capacity*load factor时就需要调整bucket的大小为当前的2倍）

put函数的实现：

	对key的hashCode()做hash，然后再计算index;
	如果没碰撞（数组上的值为null）直接放到bucket里；
	如果碰撞了，以链表的形式存在buckets后；
	如果碰撞导致链表过长(大于等于TREEIFY_THRESHOLD)，就把链表转换成红黑树；
	如果节点已经存在就替换old value(保证key的唯一性)
	如果bucket的容量超过阈值(超过capacity * loadFactor)，就要resize。

记忆：1、key做hash计算数组下标，2、是否碰撞（不碰撞，直接放入篮子；否则以链表形式放入篮子），3、如果碰撞导致链表长度过长，就把链表转成红黑树；4、如果节点存在则替换（key相等，替换值），5、如果bucket满了则resize

get函数的实现：

bucket里的第一个节点，直接命中；
如果有冲突，则通过key.equals(k)去查找对应的entry
若为**树**，则在树中通过key.equals(k)查找，O(logn)；
若为**链表**，则在链表中通过key.equals(k)查找，O(n)。

hash函数的实现：

高16bit不变，低16bit和高16bit做了一个异或

获取桶下标：
table长度n为2的幂，h&(length - 1)相当于直接取模

如何解决频繁碰撞：
首先在获取HashMap的元素时，基本分两步：1、首先根据hashCode()做hash，然后确定bucket的index；2、如果bucket的节点的key不是我们需要的，则通过keys.equals()在链中找。

在Java 8之前的实现中是用链表解决冲突的，在Java 8中，利用红黑树替换链表

扩容：
我们在扩充HashMap的时候，不需要重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成"原索引+oldCap"

## 线程局部变量

1、**Thread中有一个ThreadLocalMap属性，存放线程局部变量**，是键值对的存储方式，以ThreadLocal对象为键，要保存的变量为值（ThreadLocalMap.Entry是保存键值对的对象）

2、<font color='red'>**ThreadLocal可以看做是ThreadLocalMap的操作类**</font>，在当前线程中通过ThreadLocal的set/get操作，对当前线程中的ThreadLocalMap进行操作

* set方法：首先获取当前线程的ThreadLocalMap的引用，然后以ThreadLocal实例作为key，保存的变量为value，保存到当前线程的ThreadLocalMap中
* get方法：以当前ThreadLocal实例作为key，取出当前线程的ThreadLocalMap变量中该key的值

3、**每个线程都拥有自己的ThreadLocalMap属性，每个线程都是从自己的ThreadLocalMap中取值，所以互不影响**

4、作用：可以实现线程范围内的单例、线程范围内数据共享

## hashCode() 和equals() 区别和作用

规范1：如果两个对象相同，那么他们的hashcode必须相等
规范2：如果两个对象不相同，他们的hashcode可能相同

这样我们就可以推断Java运行时环境是怎样判断HashSet和HastMap中的两个对象相同或不同了。我的推断是：**先判断hashcode是否相等，再判断是否equals。 **

## 数据库中char, varchar, nvarchar的差异

char固定字符，varchar可变字符（根据实际所占的空间，char浪费空间，但效率略高）

varchar：按字节存储数据
nvarchar：按字符存储数据（如果用nvchar存储英文，会造成空间浪费）

1. char和varchar的性能差距是很小的，可以考虑忽略不计。
2. 在大数据量应用中，使用char和nvarchar有可能导致大量的存储空间的浪费。
3. **建议实际中用varvhar**

## mysql中int、bigint、smallint 和 tinyint的区别与长度的含义

bigint
从 -2^63 (-9223372036854775808) 到 2^63-1 (9223372036854775807) 的整型数据（所有数字）。存储大小为 8 个字节。

P.S. bigint已经有长度了，在mysql建表中的length，只是用于显示的位数

int
从 -2^31 (-2,147,483,648) 到 2^31 – 1 (2,147,483,647) 的整型数据（所有数字）。存储大小为 4 个字节。int 的 SQL-92 同义字为 integer。

smallint
从 -2^15 (-32,768) 到 2^15 – 1 (32,767) 的整型数据。存储大小为 2 个字节。

tinyint
从 0 到 255 的整型数据。存储大小为 1 字节。

## 分析MySQL数据类型的长度

（1）CHAR、VARCAHR的长度是指字符的长度，例如CHAR[3]则只能放字符串"123"，如果插入数据"1234"，则从高位截取，变为"123"。 VARCAHR同理。
（2）TINYINT、SMALLINT、MEDIUMINT、INT和BIGINT的长度，其实和数据的大小无关！Length指的是显示宽度，举个例子：

## 普通数组和ArrayList的差别

动态数组、get/set等一系列方法、基本类型/引用类型、泛型

## 动态绑定

Java的动态绑定又称为运行时绑定。意思就是说，**程序会在运行的时候自动选择调用哪个方法。**（重载）

## RESTFUL API

1、url代表一个资源
2、http的get/post/update/delete 表示对资源的操作，**进行状态转换**
3、文本类型：xml、json进行数据传递

## StringBuilder，StringBuffer

都是字符串操作类，StringBuilder非线程安全，适合在单线程的情况下使用，效率比较高；StringBuffer是线程安全的，适合在多线程条件下使用，效率略低

## 判断对象是否相等

推荐使用java.util.Objects#equals （JDK7引入的工具类）

	public static boolean equals(Object a, Object b) {
	    return (a == b) || (a != null && a.equals(b));
	}

### 类加载器

类加载器的作用是把类的字节码文件加载进内存中

类加载器的层次关系：Bootstrap、ExtClassLoader、AppClassLoader、用户自定义的类加载器

类加载器的委托机制：

1、当Java虚拟机要加载一个类时，到底派出哪个类加载器去加载呢? 
　　①首先 当前线程的类加载器 去加载线程中的第一个类. 
　　②如果类A中引用了类B，Java虚拟机将使用加载类A的类加载器加载类B 
　　③还可以直接调用ClassLoader.loadClass()方法来指定某个类加载器去加载某个类.

2、每个类加载器加载类时，又先**委托给其上级类加载器** 
　　当所有祖宗类加载器没有加载到类，回到发起者类加载器，如果还加载不了，则抛出ClassNotFoundException异常。它不会去找发起者类加载器的儿子，因为没有getChild()方法，即使有，有那么多的儿子交给那一个呢?所以干脆就不交给儿子处理了。

### ArrayList和LinkedList和Vector

1、ArrayList是实现了基于**动态数组**的数据结构，LinkedList基于**链表**的数据结构
2、对于**随机访问**get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针
3、对于**新增和删除**操作add和remove，LinedList比较占优势，因为ArrayList要移动数据

Vector和ArrayList几乎是完全相同的，唯一的区别在于**Vector是同步类**(synchronized).因此,开销就比ArrayList要大.正常情况下,大多数的Java程序员使用ArrayList而不是Vector,因为同步完全可以由程序员自己来控制

### HashMap和HashTable

![](http://i.imgur.com/38sa06k.png)

1、历史原因

Hashtable是基于陈旧的**Dictionary**类的，HashMap是java 1.2引进的Map接口的一个实现

2、同步性

Hashtable是线程同步的。这个类中的一些方法保证了Hashtable中的对象是线程安全的（Synchronized）。而HashMap则是线程异步的，因此HashMap中的对象并不是线程安全的。因为同步的要求会影响执行的效率，所以如果你不需要线程安全的集合那么使用HashMap是一个很好的选择，这样可以避免由于同步带来的不必要的性能开销，从而提高效率

3、值

HashMap可以让你将**空值**作为一个表的条目的key或value但是Hashtable是不能放入空值的(null)

### HashMap底层实现

http://zhangshixi.iteye.com/blog/672697

HashMap是基于哈希表的Map接口的**非同步**实现。此实现提供所有可选的映射操作，并允许**使用null值和null键**。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。

HashMap的数据结构：

在Java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个"链表散列"的数据结构，即数组和链表的结合体。

![](http://i.imgur.com/rdtyB5M.jpg)

从上图中可以看出，**HashMap底层就是一个数组结构，数组中的每一项又是一个链表，链表的每一个元素是键-值对**。当新建一个HashMap的时候，就会初始化一个数组。

	transient Entry[] table;  
	  
	static class Entry<K,V> implements Map.Entry<K,V> {  
	    final K key;  
	    V value;  
	    Entry<K,V> next;  
	    final int hash;  
	    ……  
	}  

可以看出，Entry就是数组中的元素，**每个 Map.Entry 其实就是一个key-value对**，它持有一个指向下一个元素的引用，这就构成了链表。

HashMap的存取实现：
   
1) 存储：

	public V put(K key, V value) {  
	    // HashMap允许存放null键和null值。  
	    // 当key为null时，调用putForNullKey方法，将value放置在数组第一个位置。  
	    if (key == null)  
	        return putForNullKey(value);  
	    // 根据key的keyCode重新计算hash值。  
	    int hash = hash(key.hashCode());  
	    // 搜索指定hash值在对应table中的索引。  
	    int i = indexFor(hash, table.length);  
	    // 如果 i 索引处的 Entry 不为 null，通过循环不断遍历 e 元素的下一个元素。  
	    for (Entry<K,V> e = table[i]; e != null; e = e.next) {  
	        Object k;  
	        if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {  
	            V oldValue = e.value;  
	            e.value = value;  
	            e.recordAccess(this);  
	            return oldValue;  
	        }  
	    }  
	    // 如果i索引处的Entry为null，表明此处还没有Entry。  
	    modCount++;  
	    // 将key、value添加到i索引处。  
	    addEntry(hash, key, value, i);  
	    return null;  
	}  

从上面的源代码中可以看出：当我们往HashMap中put元素的时候，先根据key的hashCode重新计算hash值，根据hash值得到这个元素在数组中的位置（即下标），如果数组该位置上已经存放有其他元素了，那么在这个位置上的元素将以链表的形式存放，新加入的放在链头，最先加入的放在链尾。如果数组该位置上没有元素，就直接将该元素放到此数组中的该位置上。


### 动态代理

1、必须针对接口进行代理
2、生成代理对象，通过Proxy类进行代理，传入目标对象类加载器、目标对象接口 、处理类
3、自己实现InvocationHandler 接口

### 多线程

1、thread与runnable

如果改写thread的run方法和传入runnable类，使用的是那个run？

Thread的run方法，如果runnable对象不为空，去执行runnable中的run方法，但是如果Thread的run方法被重写，则使用改写的Thread中的run方法

    public void run() {
		if (target != null) {
		    target.run();
		}
    }

2、synchronized，使用的对象锁必须**同一个对象**，可以this或字符串常量

	Synchronized(){
		//保护一段代码
	}

也可以修饰方法，来保护整个方法（默认对象锁是this）

如果修饰静态方法，静态对象对应的对象锁是**类的字节码**

### Spring MVC 和 Struts2的区别

* Struts2的入口是filter，Spring MVC的入口是Servlet，两者的实现机制不同
* Struts2是基于类设计的，参数绑定到类的属性，所有的方法都可以使用；Spring MVC是基于方法设计的，参数绑定到方法的形参，并且只有一个方法可以使用
* Struts2必须是多例的（Struts2传递到的参数绑定到类的属性，如果是单例会导致不同用户数据的冲突），Spring MVC默认是单例的，所以Spring MVC的性能比Struts2好

### 重定向与转发的区别

* 浏览器中的url：转发仍是原来的url，重定向为新的url
* 重定向发生在浏览器，由浏览器重新发出http请求，转发发生web服务器，请求在web服务器转发
* 重定向可以到外部网站，重定向只能访问WEB应用个资源

### Sesssion

**Session的生命周期**

Session存储在服务器端，一般为了防止在服务器的内存中（为了高速存取），**Sessinon在用户访问第一次访问服务器时创建，需要注意只有访问JSP、Servlet等程序时才会创建Session**，只访问HTML、IMAGE等静态资源并不会创建Session，可调用**request.getSession(true)强制生成Session**

**Session什么时候失效？**

1、服务器会把长时间没有活动的Session从服务器内存中清除，此时Session便失效。Tomcat中Session的默认失效时间为30分钟。
2、调用Session的invalidate方法。

### 分布式Session同步

1、cookie存储方式。把session数据做加密，然后存储到cookie中。用户请求到了，就直接从cookie读取，然后做解密。这种方式真是把分布式思想发挥到了一个相当的高度。他把用户也当做分布式的一员，你要访问数据，那你就自己携带着他，每次到服务器的时候，我们的服务器就只负责解密……
 
对于session里只存放小数据，并且加密做的比较好（防止碰撞做暴力破解）的系统来讲，这是一个比较好的选择。他实现超级简单，而且不用考虑数据的同步。
 
不过如果要往session里存放大数据的情况就不是太好处理。或者安全性要求很高的系统，也不是太好的一个方式（数据有被破解的风险）

2、cache集群或者数据库做session管理。我们也可以采用另外一种架构来解决session同步问题，那就是引入统一session接入点。

![](http://i.imgur.com/lcc3GzV.png)

**把session放入到cache集群或者数据库中，每次请求的时候，都从他们中来获取。**这样，所有的机器都能获取到最新的session数据。**这种方案也是很多中大型网站采用的解决方案**。他实现起来相对简单（**利用cache集群或者主从数据库自身的管理来实现多机的互备**），而且效率很高，安全性也不错。

3、还有一种方式是从上面这种方式延展出来的，就是**提供session服务**。这个服务负责管理session，其他服务器每次从这个服务处获取session数据，从而达到数据的共享。

![](http://i.imgur.com/XrcI3pE.png)

这种方式的好处就在于：

A、可以非常**方便的扩展**用户登录的数量以及存储数据的大小。当时在x度的时候，N亿用户的session都在这个系统里进行管理；
 
B、**方便做性能优化**。如果用cache集群的方案，如果cache有机器坏掉，那么就会造成一部分用户session失效；如果用数据库方案，如果量太大，有可能会出现性能问题。而这种方案在实现的时候，可以**用cache和数据库结合的实现方式，保证高效和稳定**。同时，针对一些接口，可以做性能的优化，提升查询效率；
 
C、**对外封闭，保证数据安全**。这种方式还有一个好处，就是可以将加密算法、密钥等封闭在系统内部，对外只暴露接口，使得数据安全性更有保障。（涉及到用户信息的，都是隐私！）
 
不过，这种方式也有自己的问题，就是运维相对更复杂，有可能需要专门的团队去管理这些系统。

参考：http://blog.csdn.net/zgwangbo/article/details/51636721

### 负载均衡

DNS负载均衡
反向代理负载均衡
IP负载均衡

http://www.cnblogs.com/itfly8/p/5043435.html
http://lobert.iteye.com/blog/2159970

### ConcurrentHashmap

详细见 Java - ConcurrentHashmap

ConcurrentHashMap 的高并发性主要来自于三个方面：

* 用分离锁实现多个线程间的更深层次的共享访问。（Segment继承重入锁，并且管理一定范围的数组）
* **用 HashEntery 对象的不变性**来降低执行读操作的线程在遍历链表期间对加锁的需求。（就是说当需要对链表结构进行改变时，对链表进行复制，先不更改原来的链表，然后操作完成之后再把table切换过去，在put/remove中体现）
* 通过对同一个 **Volatile** 变量的写 / 读访问，协调不同线程间读 / 写操作的内存可见性。

put/get：1、key存在：value是volatile保证可见，并且写在读之前 2、key不存在，需要插入：头插法，不影响读线程的遍历
remove/get：删除节点后面的不变，删除节点的前面节点头插法，复制完之后切换table，不影响读线程的遍历
clear/get：将table的置空，读线程仍可以访问原来的链表

<font color='red'>**get：**</font>

1、<font color='red'>**首先HashEntry对象必须用volatile修饰，否则可能会出现返回结果不为null，但是对象不可用**</font>；原因和双重检查锁定时必须将实例设为volatile一样，查看ConcurrentHashMap文章或设计模式的艺术之道笔记

2、如果的得到结果不为null，直接返回
3、如果得到的结果为null，1、可能对象不存在 2、对象刚被put线程放进去，写线程的确获取不到，读的是脏数据 => 这两种情况返回节点都指向table，如果查询的结果的确是刚插入的元素，释放锁后就能得到刚插入的结果，否则还是返回null

另一个考点：

ConcurrentHashMap的key和value不能为null

### happen before

① **程序次序法则**：线程中的每个动作A都happens-before于该线程中的每一个动作B，其中，在程序中，所有的动作B都能出现在A之后。
② **监视器锁法则**：对一个监视器锁的解锁 happens-before于每一个后续对同一监视器锁的加锁。
③ volatile变量法则：**对volatile域的写入操作happens-before于每一个后续对同一个域的读写操作。**
④ 线程启动法则：在一个线程里，对Thread.start的调用会happens-before于每个启动线程的动作。
⑤ 线程终结法则：线程中的任何动作都happens-before于其他线程检测到这个线程已经终结、或者从Thread.join调用中成功返回，或Thread.isAlive返回false。
⑥ 中断法则：一个线程调用另一个线程的interrupt happens-before于被中断的线程发现中断。
⑦ 终结法则：一个对象的构造函数的结束happens-before于这个对象finalizer的开始。
⑧ **传递性**：如果A happens-before于B，且B happens-before于C，则A happens-before于C

**我们重点关注的是②，③，这两条也是我们通常编程中常用的。**

### volatile

作用：

1、可见性：共享变量直接在主存操作，保证可见性
2、禁止指令重排：对变量进行写操作后，会产生一个内存栅栏，保证读操作必须在写操作之后，且写操作对读操作可见

应用：

1、单线程写，多线程读
2、多线程写，但是写入的值不依赖于原值

为什么用volatile修饰，多线程i++的时候计数失败？

i++不是原子操作，分为三步：1、读取 2、修改 3、写入

volatile 操作保证读操作在写操作之后，如果按以下操作：

	1、读取  2、读取 1、修改 1、写入

即多线程会对共享变量进行多次读，造成脏读；如果多线程写入不依赖原值，那么volatile可以保持同步

### 生产者消费者



### wait和sleep的区别(释放锁)


## A类B类C类IP地址

![这里写图片描述](http://img.blog.csdn.net/20151224190309198)