---
title: 11、交互字符串使之有序的最小次数

date: 2017-07-26 13:29:00

categories:
- 数据结构与算法

tags:
- 算法
- 数据结构

---

## 题目

字符序列交换（阿里巴巴笔试题）

若初始序列为gbfcdae，那么至少需要多少次两两交换，才能使该序列变为abcdefg？

注意不是相邻两两交换

## 思路

参考bcbb的回答
http://mp.weixin.qq.com/s/Kie8QP6Vq0Th-bP2Yjwx8A

	我要怼第一个人了，说是只能相邻两个交换了吗？这题例子中有两个环一个是 b b，另一个是 g a f c d e g，所以答案是字符串长度7减环的个数2等于5。因为长度为n的每一个环，都能n-1次交换满足条件。而这个例子中可以证明环不可能相交。也一不难证明一定有环。
	
	判断环的个数x，次数就是字符串长度减环的个数。

参考POJ类似题的思路和解法
http://m.blog.csdn.net/x___song/article/details/16884075
	
	实现重点在于如果角标不同 那就一直循环做
	swap(a[i], a[a[i]]);


## 常规设计思路

![](http://i.imgur.com/lepq9bp.jpg)

## 更优雅的方法——参考POJ类似题的解法

实现重点在于如果角标不同 那就一直循环做

	swap(a[i], a[a[i]]);

POJ参考代码，思路类似，题目不一样：

	#include <cstring>
	#define MAX 10000 + 10
	
	int a[MAX];
	
	void swap( int i, int j)
	{
	    int temp = a[i];
	    a[i] = a[j];
	    a[j] = temp;
	
	    return ;
	}
	
	int main()
	{
	    int t;
	    scanf("%d", &t);
	
	    while ( t --){
	        int n;
	        scanf("%d", &n);
	
	        for ( int i = 0; i < n; i ++){
	            scanf("%d", &a[i + 1]);
	        }
	
	        int ans = 0;
	        for ( int i = 1; i <= n; i ++){
	            while ( i != a[i]){ //这里需要修改为 i != a[i]应该的下标
	                ans ++;
	                swap( i, a[i]);
	            }
	        }
	        printf("%d\n", ans);
	    }
	
	    return 0;
	}
